```toc
```

## 3.1 유니캐스트, 멀티캐스트, 브로드캐스트, 애니캐스트
- 통신 방식에는 4가지가 있다
	- Unicast
		- 1:1 통신
	- Broadcast
		- 1:모든 통신
		- 동일 네트워크에 존재하는 모든 호스트가 목적지
	- Multicast
		- 1:그룹(멀티캐스트 구독 호스트) 통신
		- 하나의 출발지에서 다수의 특정 목적지로 데이터 전송
	- Anycast
		- 1:1 통신(목적지는 동일 그룹 내의 1개 호스트)
		- 다수의 동일 그룹 중 가장 가까운 호스트에서 응답
		- IPv4에서는 일부 기능 구현, IPv6은 모두 구현 가능

- 유니캐스트는 출발지, 목적지가 하나로 명확하게 정해져있는 통신
	- 사실 대부분의 경우

- 브로드캐스트는 보통 유니캐스트로 통신하기 전, 주로 상대방의 정확한 위치를 알기 위해서 사용
- 주소 체계에 따라서 브로드캐스트를 다양하게 분류할 수 있지만, 기본 동작은 로컬 네트워크에서 모든 호스트에 패킷 전달

- 멀티캐스트는 멀티캐스트 그룹 주소 사용해서 해당 그룹에 속한 다수의 호스트에게 패킷 전송
- IPTV와 같은 실시간 방송 볼 때 사용
- 사내 방송이나 증권 시세 전송등 단방향으로 다수에게 통지해야 할 때 사용

- 상대방이 데이터 수신했는지 확인하기 위해 UDP 사용
- 주소는 224.0.0.0~239.255.255.255로 정해져있음

- 소스는 네트워크에 패킷을 한 번만 전송하고, 라우터는 특정 멀티캐스트 프로토콜 사용해서 패킷 복제해서 모든 그룹 멤버에게 도달할 수 있도록 함
	- 라우터에 멀티 캐스트 정보가 담긴 트리가 존재하는듯..?

![](files/Pasted%20image%2020250301205808.png)

- 근데 결국 멀티캐스트는 라우터가 지원해야 가능한 거고, 전세계의 모든 라우터가 멀티캐스트를 지원하게 만들 수는 없으므로 터널링을 해버린다?
	- 멀티캐스트 패킷에 유니캐스트 헤더를 붙여버린다
	- 멀티캐스트 지원하는 라우터까지 유니캐스트로 보내버리고 여기서 다시 멀티캐스트로 보내는듯..?


- 애니캐스트는 애니캐스트 주소가 같은 호스트들 중에서 가장 가깝거나 가장 효율적으로 서비스할 수 있는 호스트와 통신하는 방법
- 이 특징을 이용해 가장 가까운 DNS 서버를 찾거나, 가장 가까운 게이트웨이 찾을 때도 사용


- 현재 주로 사용되는 네트워크 체계는 IPv4
- 일부 모바일 네트워크, 대규모 데이터 센터 위주로 IPv6 기반 주소 체계가 쓰이고 있음
- IPv6에서는 브로드캐스트가 존재하지 않고 링크 로컬 멀티캐스트로 대체되어 사용된다.

- BUM 트래픽
	- Broadcast, Unknown Unicast, Multicast
	- Unknown Unicast
		- 유니캐스트여서 목적지 주소가 정해져있지만 네트워크에서의 동작은 브로드캐스트와 같을 때
		- 스위치가 목적지 주소를 학습하지 못한 경우 모든 포트로 플러딩(전송)하는데, 이런 유니캐스트를 Unknown 유니캐스트라고 한다
	- BUM 트래픽이 중요한 이유는 유니캐스트이지만 실제로 겉으로 보이는 동작은 브로드캐스트에 가깝기 때문
	- 목적지가 정해져있으므로 내 패킷이 아니면 단말에서 버리지만, 네트워크 자원을 쓸데없이 사용하므로 BUM 트래픽이 많아지면 네트워크 성능이 저하될 수 있다
	- 이더넷 환경에서는 ARP 브로드캐스트를 먼저 보내고 이후에 통신을 하므로 BUM 트래픽이 많이 발생하지는 않는다


## 3.2 MAC 주소
- Media Access Control
- 2계층 통신을 위한 고유 식별자
- 이더넷, 와이파이를 포함한 IEEE 802 네트워크 기술에서 2계층 주소로 사용
- 네트워크에 접속하는 모든 장비는 MAC 주소라는 물리적인 주소가 있고, 이 주소로 서로 통신함

### 3.2.1 MAC 주소 체계
- MAC 주소는 변경할 수 없도록 하드웨어에 고정되어 출하됨
- 즉, 네트워크마다 다른 주소를 가짐
- 제조업체마다 주소 풀을 주고, 그 안에서 자체적으로 MAC 주소 할당
	- 이렇게 풀 할당하는 걸 제조사 코드(Vendor Code)라고 하며, IEEE가 관리

- 48비트
- 앞 24비트가 제조사 코드인 OUI(Organizational Unique Identifier)
- 뒤 UAA(Universally Administered Address)는 각 제조사에서 자체적으로 할당하는 값

- 네트워크 카드나 장비에 하드웨어적으로 주소가 정해지니, MAC 주소를 BIA(Burned-In Address)라고도 부른다

> 가상 머신에서는 MAC 주소는 완전히 랜덤일까? 궁금해서 찾아봤는데 가상 머신 별로 고유한 조직 ID를 사용하는 것 같더라구요. VMware의 경우 MAC 주소는 보통 00:50:56으로 시작, Hyper-V는 00:15:5D로 시작


- 유일하지 않은 MAC 주소
	- 제조업체에서 알아서 할당하는 값이므로 실수 혹은 의도적으로 중복될 수 있다
	- 다만 MAC 주소는 동일 네트워크에서만 중복되지 않으면 문제가 없다
	- 다른 네트워크로 넘어갈 때 출발지, 도착지 MAC 주소가 바뀌기 때문

- MAC 주소 변경
	- BIA 상태로 NIC에 할당되어있음
	- 일반적으로는 ROM 형태로 고정되어 출하되므로 변경하기 어렵다
	- 다만, 결국 MAC 주소도 메모리에 적재되어 구동되므로 변경이 불가능하지는 않다
	- 보안상의 이유로 MAC 주소 변경을 막아둔 운영체제도 있지만, 손쉽게 변경할 수 있는 경우도 있다

### 3.2.2 MAC 주소 동작
- NIC는 자신의 MAC 주소를 가지고 있다가, 전기 신호가 들어오면 2계층에서 패킷으로 변환 후 MAC 주소가 다르면 폐기한다
- 자기 자신이거나, 브로드 캐스트, 멀티캐스트면 상위 계층으로 올려보낸다

- 브로드캐스트나 자기 자신에게 온 패킷은 상위 계층으로 올라가므로 시스템에 부하가 생긴다
- 브로드캐스트 스톰의 경우, 브로드캐스트가 회선을 모두 채우게 되는데 네트워크의 모든 단말이 브로드캐스트 처리하느라 CPU 사용량 증가한다

- 무차별 모드(Promiscuous Mode)
	- 모니터링, 디버그, 분석 용도로 네트워크의 전체 패킷을 수집해볼 수 있다
	- 무차별 모드는 자신의 MAC 주소와 상관없는 패킷이 들어와도 이를 분석할 수 있도록 메모리에 올려서 처리한다

- MAC 주소를 여러 개 갖는 경우
	- MAC 주소는 단말이 아니라 NIC에 종속된다
	- 단말은 여러 개의 NIC를 가질 수 있으므로 MAC 주소도 여러 개 가질 수 있다

- MAC 주소는 [IEEE 홈페이지](https://regauth.standards.ieee.org/standards-ra-web/pub/view.html#registries)에서 확인할 수 있다

## 3.3 IP 주소
- 2계층은 MAC 주소를, 3계층은 IP 주소를 사용
- IP 주소를 포함한 다른 프로토콜 스택의 3계층 주소는 아래와 같은 특징을 가짐
	- 사용자가 변경 가능한 논리 주소
	- 네트워크 주소와 호스트 주소로 나눌 수 있음

### 3.3.1 IP 주소 체계
- 흔히 사용하는 IP 주소는 32비트인 IPv4
	- 8비트 단위인 4개의 옥텟으로 구성, 각 옥텟은 `.`으로 구분
- IPv6 주소는 128비트

- IP 주소는 네트워크 주소, 호스트 주소로 나뉨
	- 네트워크 주소
		- 호스트들을 모은 네트워크를 지칭하는 주소
		- 네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 함
	- 호스트 주소
		- 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소

- MAC 주소는 24비트씩 절반으로 구분하지만, IP 주소는 경계점이 고정되어있지 않다
	- 다른 주소 체계와 가장 큰 차이점
- IP 주소 체계는 필요한 호스트 IP 개수에 따라 네트워크 크기를 다르게 가져갈 수 있는 클래스(Class) 개념을 도입

![](files/Pasted%20image%2020250302212017.png)

- A 클래스는 1,600만 개의 IP, B 클래스는 약 6만 6천 개, C 클래스는 약 250개
- A 클래스는 첫 번째 옥텟, B 클래스는 두 번째 옥텟, C 클래스는 세 번째 옥텟에 구분자가 있는데 이를 서브넷 마스크라고 한다.

- 네트워크 크기를 유동적으로 조정할 수 있게 됨으로써 큰 네트워크가 필요한 곳에서는 하나의 네트워크를 사용하고, 작은 네트워크가 필요한 곳에서는 낭비 없이 필요한 만큼 IP를 사용할 수 있다

![](files/Pasted%20image%2020250302212110.png)

- 각 클래스는 앞 옥텟의 주소만 보고 구분할 수 있다.
- 앞 주소가 0~127이면 A 클래스
	- 즉, 첫 옥텟의 2진수 8자리 중 맨 앞자리가 0인 주소가 A 클래스
	- 마지막 주소는 자신을 의미하는 루프백(Loopback) 주소로 사용하므로 실제로는 1.0.0.0 ~ 126.255.255.255 까지
- B 클래스는 첫 옥텟 이진수가 10~인 경우
- C 클래스는 첫 옥텟 이진수가 110~

- 클래스 분할 기법은 과거에 사용했던 개념으로 지금은 클래스 기반으로 네트워크를 분할하지 않는다
- 대신 필요한 네트워크 크기에 맞추어 1비트 단위로 네트워크를 상세히 분할하는 방법을 사용

- 네트워크에서 사용 가능한 호스트 개수 파악하기
	- 네트워크 주소 : 172.16.0.0
	- 브로드캐스트 주소 : 172.16.255.255
	- 유효 IP 범위 : 172.16.0.1 ~ 172.16.255.254
	- 즉, 2^16 - 2 = 65534

- IP 체계에서는 맨 앞의 숫자를 네트워크 주소로, 맨 뒤의 숫자를 브로드캐스트 주소로 사용
- 즉, 2 ^ N - 2개가 사용 가능한 IP 주소 수

### 3.3.2 클래스풀과 클래스리스
- 클래스 기반의 IP 주소 체계를 클래스풀(Classful)이라고 부른다
- IP 주소 체계를 처음 만들 때 클래스 개념을 도입한 건 확장성있고, 주소 낭비가 적은 좋은 선택이었다
- 이 주소 체계에서는 네트워크 주소와 호스트 주소를 구분짓는 구분자가 필요없었다 (서브넷 마스크)
	- 맨 앞자리 숫자만 보면 알 수 있었음

#### 3.3.2.1. 클래스리스 네트워크의 등장
- 인터넷이 상용화되면서 호스트 숫자가 폭발적으로 증가
- 기존 클래스풀 기반 주소 체계는 확장성과 효율성을 모두 잡는 좋은 주소 체계였지만 기하급수적으로 늘어나는 IP 주소 요구를 감당하기엔 부족했다
- 이론적으로 사용할 수 있는 IP 개수는 43억개지만 실제로 사용할 수 있는 IP 주소는 이보다 적다
	- 전 세계 인구가 하나의 IP만 가져도 불가능한 크기이고
	- 네트워크 주소를 계층화하고 분할하기 위해 낭비되는 IP가 매우 많았다
	- 하나의 네트워크에서 IP가 사용되지 않더라도 그 IP를 다른 네트워크에서 사용하지 못했다
- IP 주소 부족, 낭비 문제를 해결하기 위해서 3가지 보존, 전환 전략을 만들어냄
	- 첫 번째 단기 대책은 클래스리스, CIDR(Classless Inter-Domain Routing) 기반 주소 체계
	- 두 번째 중기 대책은 NAT와 사설 IP 주소
	- 세 번째 장기 대책은 IPv6

- IPv4의 가장 큰 문제는 주소 자체의 부족 문제도 있지만 상위 클래스를 할당 받은 조직에서 이 주소를 제대로 사용하지 못하면서 낭비하는 것
- 인터넷 초창기에 여러 회사에서 미래를 위해 IP를 많이 확보할 수 있는 A 클래스를 할당받았지만 실제로는 수천, 수만 개만 사용하는 곳이 대부분이었고 나머지 수천만 개의 IP는 사용되지 못했다
- 클래스풀에서는 한 개의 클래스 네트워크가 하나의 조직에게 할당되면 아무리 비어있는 주소라도 IP를 분할해 다른 기관에서 사용할 수 없었다
- 이런 문제를 해결하기 위해서 클래스 개념 자체를 버리는데 이를 클래스리스라고 부른다
- 현재 우리가 사용하는 주소 체계도 클래스 개념을 적용하지 않는 클래스리스 기반 주소 체계

- 클래스 네트워크와 다르게 클래스리스 기반 네트워크는 IP 주소만 보고는 네트워크와 호스트를 구분할 수 없기에 별도의 구분자가 필요한데 이를 서브넷 마스크(Subnet Mask)라고 부른다.

![](files/Pasted%20image%2020250302215425.png)

- 서브넷 마스크는 IP 주소와 네트워크 주소를 구분할 때 사용
- 2진수 숫자 1은 네트워크 주소, 숫자 0은 호스트 주소로 표시
- 255.0.0.0, 255.255.0.0 등으로 표현
- 103.9.32.146 주소에 255.255.255.0 서브넷 마스크를 사용하면
- 네트워크 주소는 103.9.32.0, 호스트 주소는 0.0.0.146이 된다

- 클래스리스 기반의 IP 네트워크에서는 네트워크를 표현하는 데 반드시 서브넷 마스크가 필요하고 서버나 PC에 IP 주소를 부여할 때도 사용되어야 한다.

![](files/Pasted%20image%2020250302215638.png)
![](files/Pasted%20image%2020250302215703.png)

- 서브넷 마스크 표현 방법
	- 비트 단위로 표현할 떄도 있고 10진수 단위로 표현하기도 함
	- 비트 단위는 서브넷 마스크에서 1 부분이 연속된 자릿수 표현
	- A 클래스는 /8, B 클래스는 /16, C 클래스는 /24로 표기
	- 10진수로 표현할 떄는
	- A 클래스는 255.0.0.0, B 클래스는 255.255.0.0, C 클래스는 255.255.255.0

### 3.3.3 서브네팅
- 원래 부여된 클래스 기준을 무시하고 새로운 네트워크-호스트 구분 기준을 사용자가 정해서 원래 클래스풀 단위의 네트워크 단위보다 더 쪼개서 사용하는 걸 서브네팅(Subnetting)이라고 부른다
- 부여된 주소를 다시 잘라 사용해 서브네팅이라고 부름
- 이는 현대 클래스리스 네트워크의 가장 큰 특징

- 옥텟 단위로 구분되는 서브네팅은 이해와 운영이 쉽지만 실제로는 옥텟 단위보다 더 잘게 네트워크를 쪼개 2진수 1비트 단위로 네트워크를 분할하므로 서브네팅을 이해하기 어렵다.

![](files/Pasted%20image%2020250302215950.png)

- 실무에서 서브네팅에 대해 고민해야 하는 것은 두 가지다
	- 디자인 단계에서 어떻게 네트워크를 효율적으로 분할할 것인지
	- 이미 분할된 네트워크에서 사용자가 자신의 네트워크와 원격지 네트워크를 구분해야 하는 경우
- 상황에 따라 고려해야 할 요소와 범위가 달라진다
	- 네트워크 사용자 입장
		- 네트워크 내에 사용할 수 있는 IP 범위 파악
		- 기본 게이트웨이와 서브넷 마크스 설정이 제대로 되어있는지 확인
	- 네트워크 설계자 입장
		- 네트워크 내에 필요한 단말을 고려한 네트워크 범위 설계

#### 3.3.3.1 네트워크 사용자의 서브네팅
- 사용자는 이미 설계되어있는 네트워크에서 사용할 수 있는 IP 주소 범위 파악해야 한다
- 주어진 네트워크 범위 밖의 IP를 할당하거나 서브넷 마크스를 잘못 입력하면 로컬 네트워크의 특정 범위에 속해있는 단말과 통신에 문제가 생기거나 외부 네트워크 전체와 통신하지 못함
- 옥텟 단위가 아닌 비트 단위로 네트워크를 쪼개는 서브네팅에서는 더 판단이 어려움

![](files/Pasted%20image%2020250302220514.png)

- 내 IP와 서브넷 마스크를 2진수로 표현 후
- AND 연산으로 서브네팅된 네트워크 주소를 얻고
- 호스트 주소 부분을 모두 1로 변경해 브로드캐스트 주소를 얻고
- 네트워크 주소  + 1 ~ 브로드캐스트 주소 -1이 유효 IP

![](files/Pasted%20image%2020250302220919.png)

- 혹은 서브넷 마스크를 먼저 이진수로 변환 후
- 서브넷이 가질 수 있는 최대 IP 개수 파악 2 ^ N
- 64의 배수로 나열해어 기준이 되는 네트워크 주소 파악
	- 0 ~ 63,  64 ~ 127, 128~191, 192 ~ 255
	- 각 네트워크 마지막 주소는 브로드캐스트 주소가 된다
- 이 중에서 호스트 주소가 속한 네트워크 선택
- 이를 통해 네트워크 주소, 브로드캐스트 주소, 유효 IP 범위 얻어낸다

#### 3.3.3.2 네트워크 설계자 입장
- 설계자는 네트워크 크기를 고민해 서브넷 마스크를 결정하고 설계에 반영해야 한다
	- 서브넷된 하나의 네트워크에 IP를 몇 개나 할당해야 하는가?
	- 서브넷된 네트워크가 몇 개나 필요한가?

- 회사에 12개의 지사가 있고, 지사에는 최대 12대의 IP가 필요한 PC, 복합기, IP 카메라 필요
- 현재 가진 네트워크는  103.9.32.0/24 네트워크
	- 서브넷된 하나의 네트워크에 12개의 IP 할당 필요
	- IP 개수는 2의 배수로 커지므로 가장 작은 네트워크는 16개짜리
		- 16개짜리 네트워크를 사용할 때 실제로는 네트워크 주소와 브로드캐스트 주소 2개 IP 주소는 제외해야 하므로 14개만 실제로 사용 가능
	- 16개짜리 네트워크 12개를 확보. 16의 배수를 0부터 나열해 네트워크 주소 확인
	- 총 16개의 네트워크 중 12개의 네트워크 할당

- 네트워크를 설계할 때는 가능하면 사설 IP 대역을 사용해 충분한 IP 대역을 사용하는 게 좋다
- 공인 IP는 인터넷에서 유일하게 사용되므로 사용할 수 있는 IP 주소가 제한되어 있고, 할당 받은 IP 주소를 사용하지 않으면 IP 할당기관이 회수한다
- 하지만 사설 IP는 회사 내부에서만 사용하므로 제한없이 큰 네트워크를 사용할 수 있다

- 공인 IP를 사용해 여유 없이 네트워크를 할당하면 크기가 다른 네트워크가 많아진다
- 그러면 네트워크 관리자 입장에서 관리가 힘들어지고 일반 사용자도 IP를 쉽게 구분하거나 알아볼 수 없게 되므로 최대한 같은 크기의 네트워크를 할당하고 10진수로 표현해도 쉽게 이해할 수 있는 C 클래스 단위인 24비트로 쪼개 할당하는 것이 바람직하다

- 네트워크를 단계적으로 잘 쪼개면 관리하기 쉽고 네트워크 장비 성능도 향상된다
- 잘 설계된 네트워크는 라우터가 관리하는 경로가 적고 관리도 쉽다
	- 단, IP 주소가 낭비될 수 있으므로 여유있게 사용할 수 있는 사설 IP 대역으로 네트워크를 설계해야 한다

![](files/Pasted%20image%2020250302221911.png)

### 3.3.4 공인 IP와 사설 IP
- 인터넷에 접속하려면 IP 주소가 필요하고, 이 IP는 전 세계에서 유일해야 하는 식별자
- 이를 공인 IP라고 부른다

- 하지만 인터넷에 연결하지 않고 개인적으로 네트워크를 구성한다면 공인 IP 주소 없이 네트워크를 구축할 수 있다
- 이때 사용하는 IP 주소를 사설 IP 주소라고 한다
- 인터넷에 접속하려면 통신사업자로부터 IP 주소를 할당받거나 IP 할당기관에서 인터넷 독립기관주소를 할당받은 후 독립 IP를 할당받아야 하므로 절차가 복잡하다
- 인터넷에 접속하지 않거나 NAT(Network Adress Translation) 기술을 사용할 경우 사설 IP 주소를 사용할 수 있다

- 이 주소들은 인터넷 표준인 RFC에 명시되어 있다
- 사설 IP를 사용하면 인터넷에 직접 접속은 못하지만 IP를 변환해주는 NAT 장비에서 공인 IP로 변경한 후에는 인터넷 접속이 가능하다
	- 공유기가 대표적인 예시

- 인터넷 표준
	- RFC(Request for Comments)와 그 집합을 가리킨다
	- RFC는 원래 비평을 기다리는 문서로, 자체가 인터넷 표준 문서는 아니며 컴퓨터, 인터넷 기술에 적용할 수 있는 제안, 조사 결과, 아이디어, 표준 등을 적어놓은 메모 형식의 문서 모음
	- RFC 문서 중 의미있는 표준 문서는 IETF를 통해 표준으로 인정받는다
	- 새로운 인터넷 표준이 되는 RFC는 인터넷 드래프트로 시작하고 여러 번의 수정을 거친 후 정식으로 RFC로 출판된다

![](files/Pasted%20image%2020250302223958.png)

- 회사 내부에서 사설 네트워크를 구축할 때 NAT를 사용하여 인터넷에 연결하더라도 다른 사용자에게 할당된 IP를 사설 네트워크 주소로 사용하면 안 된다
- 다른 인터넷 연결에는 문제가 없지만 내부 네트워크에 할당된 IP를 공식으로 사용하는 네트워크로 접속할 수 없으므로 인터넷 어느 구간에서도 사용하지 않는 RFC에 명시된 사설 IP 대역을 사용하는 것을 추천한다.
	- 같은 IP를 쓰는 외부 호스트에게 접근할 수 없다

- 사설 IP는 A 클래스는 1개, B 클래스는 16개, C 클래스는 256개를 사용할 수 있다
- 엔터프라이즈 네트워크에서는 A 클래스 크기인 10.0.0.0/8 네트워크를 사용하고 규모가 작은 네트워크에서는 192.168.x.0/24를 많이 사용한다
- 아이폰, 갤럭시와 같은 모바일 디바이스에서는 가장 많이 사용되는 10점대 A 클래스와 192.168.x.0/24번대 C 클래스와 겹치지 않도록 B 클래스인 172.x.x.x 네트워크를 이용해 테더링 기능을 제공하고 있다.

- Bogon IP
	- 모든 IP가 인터넷에서 사용되지는 않는다
	- IP 주소 할당하는 최상위 기구인 IANA가 여러 가지 목적으로 예약해둬 공인 IP로 할당되지 않는 주소를 Bogon IP라고 부른다
	- 즉, 인터넷에는 이 IP가 존재하지 않으므로 이를 이용한 통신 시도가 있었다면 해킹 목적으로 IP를 스푸핑했거나 실수로 할당된 IP를 사용한 것이므로 필터링하는 게 좋다
		- 물론 Bogon IP 주소가 바뀔 수도 있으니 이를 확인할 필요가 있다

https://ipinfo.io/bogon

![](files/Pasted%20image%2020250302224737.png)

## 3.4 TCP와 UDP
- 4계층에서 동작하는 프로토콜은 만들어진 목적이 2, 3계층과 좀 다르다
- 목적지 단말 안에서 동작하는 여러 애플리케이션 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가고, 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내기 위한 역할을 한다

### 3.4.1 4계층 프로토콜(TCP, UDP)과 서비스 포트
- 데이터를 보내고 받는 인캡슐레이션, 디캡슐레이션 과정에 각 계층에서 정의하는 헤더가 추가되고 여러 가지 정보가 들어간다
- 다양한 정보 중 가장 중요한 두 가지는
	- 각 계층에서 정의하는 정보
	- 상위 프로토콜 지시자 정보

![](files/Pasted%20image%2020250303191717.png)

- 각 계층에서 정의하는 정보는 수신 측의 동일 계층에서 사용하기 위한 정보
	- 송신 측에서 추가한 2계층 헤더의 MAC 헤더는 수신 측의 2계층에서 확인하고 사용
	- 3계층 IP도 마찬가지
	- 4계층의 경우 시퀀스 번호, ACK 번호 등

- 상위 프로토콜 지시자는 디캡슐레이션 과정에서 상위 계층의 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용된다
- 2계층은 이더 타입, 3계층은 프로토콜 번호, 4계층은 포트 번호가 상위 프로토콜 지시자다

- TCP/IP 프로토콜 스택에서 4계층은 TCP, UDP가 담당한다
- 4계층의 목적은 목적지를 찾아가는 주소가 아니라 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고 데이터를 분할한 패킷을 잘 쪼개 보내고 조립하는 것
- 이를 위해 TCP에서는 시퀀스 번호, ACK 번호를 사용

![](files/Pasted%20image%2020250303191936.png)

- TCP/IP 프로토콜 스택에서 4계층 사우이 프로토콜 지시자는 포트 번호
- 3계층의 프로토콜 번호나 2계층의 이더 타입과 같은 상위 프로토콜 지시자는 출발지와 도착지를 구분해서 사용하지 않지만 4계층의 포트 번호는 출발지와 목적지를 구분해야 한다.

- 평소 우리가 표현하는 포트 번호 기준은 서버의 포트다
	- HTTP TCP 80, HTTPS TCP 443, SMTP TCP 25와 같이 잘 알려진 포트를 Well Known 포트라고 한다.
	- 이는 IANA에 등록되고, 1023번 이하의 포트 번호를 사용한다.

- 다양한 애플리케이션에 포트 번호를 할당하기 위해서는 Registered Port 범위를 사용한다
- 1024 ~ 491515 범위
- 포트 번호를 할당받기 위해 신청하면 IANA에 등록되어 관리되지만 공식 번호와 비공식 번호가 혼재되어 있고, 사설 포트 번호로 사용되기도 한다.

- 동적, 사설, 임시 포트 번호의 범위는 49152 ~ 65535
- 이 범위는 IANA에 등록되어 사용되지 않으며 자동 할당되거나 사설 용도로 할당되고 클라이언트의 임시 포트 번호로 사용된다.

![](files/Pasted%20image%2020250303192322.png)

- 서비스 요청 시와 응답 시에 출발지 IP와 도착지 IP가 반대가 되듯이 출발지와 도착지 포트 번호도 반대가 된다.

### 3.4.2 TCP
- TCP는 4계층의 특징을 대부분 포함하고 있다
- TCP 프로토콜은 신뢰할 수 없는 공용망에서도 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 분할된 패킷이 잘 전송되었는지 확인하는 기능이 있다
- 패킷에 번호(Sequence Number)를 부여하고 잘 전송되었는지에 대해 응답(Acknowledge Number)합니다.
- 한꺼번에 얼마나 보내야 수신자가 잘 받아 처리할 수 있는지 전송 크기(Window Size)까지 고려해 통신한다
- TCP의 이런 역할 덕분에 네트워크 상태를 심각하게 고려하지 않고 특별한 개발 없이도 쉽고 안전하게 네트워크를 사용할 수 있다

#### 3.4.2.1 패킷 순서, 응답 번호
![](files/Pasted%20image%2020250303192548.png)
- TCP에서는 분할된 패킷을 수신 측이 잘 조합할 수 있도록 패킷에 순서를 주고 응답 번호를 부여한다
- 패킷에 순서를 부여하는 것을 시퀀스 번호, 응답 번호를 부여하는 것을 ACK 번호라고 부른다
- 두 번호 덕분에 중간에 패킷이 손실된 것을 파악할 수 있다

- 보내는 쪽에 패킷 번호를 부여하고, 받는 쪽은 이 번호의 순서가 맞는지 확인한다
- 받은 패킷 번호가 맞다면 응답을 주는데 이때 다음 번호의 패킷 번호를 요청한다. 이 숫자를 ACK 번호라고 부른다
- 송신 측이 1번 패킷을 보냈는데 수신 측이 이 패킷을 잘 받는다면 1번을 잘 받았으니 다음에는 2번을 달라는 표시로 ACK 번호를 2번을 준다

![](files/Pasted%20image%2020250303194247.png)
- 출발지에서 시퀀스 번호를 0으로 보낸다 (SEQ = 0)
- 수신 측에서는 0번 패킷을 잘 받았다는 표시로 응답 번호(ACK)에 1을 적어서 응답. 이때 수신 측에서는 처음 보내는 패킷이므로 자신의 패킷에 시퀀스 번호 0을 부여한다
- 이 패킷을 받은 송신측은 시퀀스 번호를 1로(수신 측이 ACK 번호로 1번 패킷을 달라고 요청했으므로), ACK 번호는 상대방의 0번 시퀀스를 잘 받았다는 의미로 시퀀스 번호를 1로 부여해 다시 송신

> 제 기억이 맞다면 책에서는 설명이 쉽도록 0부터 SEQ 번호가 시작하고 있지만 실제로는 랜덤한 값이 담깁니다. 그리고 이 번호를 ISN(Initial Sequence Number)라고 부르고요.
> 이는 과거에 두 호스트가 사용했던 포트 번호를 재사용하는 경우 이전 커넥션과 현재 커넥션을 혼동하는 가능성을 줄이기 위해서 난수를 사용하는 것으로 알고 있습니다.

#### 3.4.2.2 윈도우 사이즈와 슬라이딩 윈도우
- TCP는 일방적으로 패킷을 보내는 것이 아니라 상대방이 잘 받아야 다음 패킷을 보낸다
- 패킷이 잘 전송되었는지 확인하기 위해 별도 패킷을 받는 것 자체가 통신 시간을 늘리지만, RTT가 긴 경우 응답을 기다리는 시간은 더 길어진다
- 작은 패킷을 하나 보내고 응답을 받아야만 하나를 또 보낼 수 있다면 너무 오래 걸리므로 한 번에 많은 패킷을 보내고 응답을 하나 받는 방법을 택한다
- 최대한 많은 패킷을 보내는 게 효율적이지만 네트워크 상태가 좋지 않으면 패킷 유실 가능성이 커지므로 적절한 송신량을 결정해야 한다
- 한 번에 데이터를 받을 수 있는 데이터 크기를 윈도우 사이즈라고 한다.
- 네트워크 상황에 따라 이 윈도우 사이즈를 조절하는 것을 슬라이딩 윈도우라고 한다.

![](files/Pasted%20image%2020250303194726.png)
- TCP 헤더에서 윈도 사이즈로 표현할 수 있는 최대 크기는 2 ^ 16
	- tcp 헤더에 2 byte size
- 실제로 64K만큼 윈도우 사이즈를 가질 수는 있지만 이 사이즈는 회선의 안정성이 높아지고 고속화되는 현대 네트워크에서는 너무 작은 숫자다
	- RTT  10ms 일때, 64Kbytes/0.01sec = 51.2Mbps
	- RTT  40ms 일때, 64Kbytes/0.04sec = 12.5Mbps
	- RTT 100ms 일때, 64Kbytes/0.001sec = 5.12Mbps
- 고속화, 안정화되는 환경에 적응하기 위해 윈도우 사이즈를 64K보다 대폭 늘려 통신하는데 TCP 헤더는 변경이 불가능하므로 헤더 사이즈를 늘리지 않고 뒤의 숫자를 무시하는 방법으로 윈도우 사이즈를 증가시켜 통신한다.
- 이 방법을 사용하면 기존 숫자에 10배, 100배로 윈도우 사이즈가 커진다.

- 더 찾아본 건
	- 스케일링 팩터는 2의 거듭제곱으로, 연결 설정 중 결정
	- 예를 들어, 팩터가 3이면 실제 크기는 헤더 값에 2 ^ 3 곱한 값
	- 스케일링 팩터는 0에서 14까지의 시프트 카운트로, 최대 2^14=16,384까지 가능
		- 최대 1GB

- TCP는 데이터에 유실이 발생하면 윈도우 사이즈를 절반씩 떨어뜨리고 정상적인 통신이 되는 경우 서서히 하나씩 늘린다
- 네트워크에 경합이 발생해 패킷이 드롭되면 작아진 윈도우 사이즈로 인해 데이터 통신 속도가 느려져 회선을 제대로 사용하지 못할 수 있다
- 이런 경우 경합을 피하기 위해 회선 속도를 올리거나 경합을 임시로 피하게 할 수 있는 버퍼가 큰 네트워크 장비를 사용하거나 TCP 최적화 솔루션을 사용해 이런 문제를 해결할 수 있다.

![](files/Pasted%20image%2020250303202640.png)
![](files/Pasted%20image%2020250303203213.png)


- Slow Start
	- TCP Session이 처음 생성되거나 RTO(retransmission timeout)이 발생한 경우 동작
	- 네트워크 상태를 모르니 혼잡이 발생하지 않도록 CWND를 천천히 증가시키는 단계
	- CWND는 1로 시작해 ACK를 수신할 때마다 1씩 증가
	- 송신측은 RTT동안 CWND 만큼의 패킷을 전송할 수 있으므로 모든 전송된 패킷의 ACK를 받으면 RTT마다 CWND는 2배씩 지수적으로 증가한다
	- 왜 2배씩 증가하는데 Slow Start인가 하면 UDP는 처음부터 최대로 전송하기 때문이다?
	- 그렇다면 Slow Start는 언제 종료되는가?
	- CWND 2배씩 늘리다가 패킷 드랍에 의한 RTO가 발생하면 네트워크가 수용 가능한 전송량에 도달했다고 판단 후 Slow Start를 종료하는 임계점인 ssthresh를 설정
	- CWND를 두 배로 늘려 드랍이 발생했으므로 ssthreash는 두 배로 늘리기 전인 값으로 설정하고, CWND 값은 1로 리셋
	- 그 이후 다시 Slow Start를 수행하는데, CWND 값이 ssthreash 값보다 커지면 네트워크 용량에 도달핬다고 판단해 Slow Start를 종료하고 congestion Avoidance 단계로 들어간다
- Congestion Avoidance
	- Congestion Control의 핵심, 알고리즘에 따라 각기 다른 방식 사용
	- Reno 계열의 Congestion Avoidance는 ACK를 수신하면 CWND를 1/CWND 씩 늘린다
	- 즉, 모든 전송된 패킷을 수신하면 RTT당 1씩 증가
	- 패킷 드랍은 2가지로 구분
		- RTO 
			- Slow Start로 돌아감
			- ssthreash는 CWND/2, CWND는 1로 리셋 
		- 3 dup-ACK
			- 동일한 seq num의 ack를 3번 수신한 경우 (timeout이 발생하지 않아도)
			- 이 경우 송신측은 재전송을 시도하는데 fast retransmit
			- RTO에 비해 심각한 상황은 아니므로 CWND를 1로 초기화하는 대신 절반으로 줄여 전송량을 유지하고 함 -> Fast Recovery 단계 돌입
- Fast Recovery
	- ssthresh를 절반으로 줄이고
	- CWN는 절반이 된 ssthresh 값에 3을 더함
		- 이는 3-dup ack 영향을 고려
		- dup-ack는 한 패킷에 대한 드랍은 일어났지만 그 뒤 패킷은 정상적으로 전송되었다는 것을 의미
		- 원래라면 성공적으로 수신한 3개의 패킷만큼 CWND를 3칸 옮겨주면 되지만 CWND 맨 앞이 ACK 수신하지 못해 막혔으므로 사이즈를 3 늘려줌
	- Fast Recovery 단계에서 드랍된 패킷이 성공적으로 재전송되지 않아 계속 4, 5 dup-ack 받으면 CWND를 위와 같은 이유로 1씩 늘려줌
	- 드랍된 패킷의 ACK를 받으면 CWND를 ssthresh 값으로 낮춰 Fast Revoery 단계에서 부풀려진 CWND 값을 줄이고 Congestion Avoidance 단게로 돌입
	- 즉, Congestion Avoidance에서 3-dup ack로 인해 Fast recovery 상태를 거치고 다시 Congestion Avoidance 단게로 돌아오면 CWND는 1/2이 된다

#### 3.4.2.3 3방향 핸드셰이크
- TCP는 유실 없는 안전한 통신을 위해 통신 시작 전, 사전 연결 작업을 진행
- 목적지가 데이터를 받을 준비가 안 되어있는 상황에서 데이터를 일방적으로 전송하면 목적지에서는 데이터를 정상적으로 처리할 수 없어 데이터가 버려진다
- TCP 프로토콜은 이런 상황을 만들지 않기 위해 통신 전, 데이터를 안전하게 보내고 받을 수 있는지 미리 확인하는 작업을 거친다.
- 패킷 네트워크에서는 동시에 많은 대상과 통신하므로 정확한 통신을 위해서는 통신 전, 각 통신에 필요한 리소르를 미리 확보하는 작업이 중요하다
- TCP에서는 3번의 패킷을 주고받으면서 통신을 서로 준비하므로 3-way handshake라고 부른다

![](files/Pasted%20image%2020250303195732.png)

- TCP는 이런 3방향 핸드셰이크 진행 상황에 따라 상태 정보를 부르는 이름이 다르다
- 서버에서는 서비스를 제공하기 위해 클라이언트의 접속을 받아들일 수 있는 LISTEN 상태로 대기한다
- 클라이언트에서는 통신을 시도할 때 Syn 패킷을 보내는데 클라이언트에서는 이 상태를 SYN-SENT라고 부른다
- 클라이언트의 Syn 서버를 받은 서버는 SYN-RECEIVE 상태로 변경되고 Syn, Ack로 응답한다
- 이 응답을 받은 클라이언트는 ESTABLISHED 상태로 변경하고 그에 대한 응답을 서버로 다시 보낸다
- 서버에서도 클라이언트의 응답을 받고 ESTABLISHED 상태로 변경된다
- ESTABLISHED 상태는 서버와 클라이언트 간의 연결이 성공적으로 완료되었음을 나타낸다.

![](files/Pasted%20image%2020250303201300.png)

- 3방향 핸드셰이크 과정이 생기다 보니 기존 통신과 새로운 통신을 구분해야 한다
- 어떤 패킷이 새로운 연결 시도이고 기존 통신에 대한 응답인지를 구분하기 위해 헤더에 플래그 값을 넣어 통신하다

- TCP 플래그는 총 6가지
- 초기 연결, 응답, 정상 종료, 비정상 종료 등의 용도로 사용된다.

- SYN
	- 연결 시작 용도
	- SYN 플래그에 1 표시
- ACK
	- ACK 번호가 유효할 경우 1로 표시
	- 초기 SYN이 아닌 모든 패킷은 기존 메시지에 대한 응답이므로 ACK 플래그가 1로 표시
- FIN
	- 연결 종료 시 1로 표시
	- 데이터 전송 후 정상적으로 양방향 종료 시 사용
- RST
	- 연결 종료 시 1로 표시
	- 연결 강제 종료를 위해 연결을 일방적으로 끊을 때 사용
- URG
	- 긴급 데이터인 경우 1로 표시
- PSH
	- 서버 측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달할 것을 지시할 때 사용

![](files/Pasted%20image%2020250303201742.png)

- 통신을 처음 시도할 때 송신자는 플래그에 있는 SYN 필드르 1로 표기해 패킷을 보낸다
	- 이때 자신이 사용할 첫 seq no를 적어 보낸다
- 이 SYN 패킷을 받은 수신자는 SYN과 ACK 비트를 플래그에 1로 표기해 응답
- 자신이 보내는 첫 패킷이므로 SYN을 1로 표기하고 기존 송신자가 보냈던 패킷의 응답이기도 하므로 ACK 비트도 1로 표기
	- 이 패킷은 송신자의 연결 시도를 허락하는 의미로 사용
	- 자신이 사용할 시퀀스 넘버를 적어서 보내고, ACK 번호는 송신자가 보낸 시퀀스 번호에 1을 추가한 값
- 수신자의 응답을 받은 송신자는 연결을 확립하기 위해 다시 한 번 응답 메시지를 보낸다
- 이떄부터는 기존 메시지의 응답이므로 ACK 필드만 1로 표기

### 3.4.3 UDP
- UDP는 4계층 프로토콜이 가져야 할 특징이 거의 없다
- TCP는 데이터를 잘 분할하고 조립하기 위해 번호를 붙이고, 수신한 데이터를 응답하는 작업이 있었다
- 또한 데이터를 특정 단위로 보내고 메모리에 유지하고 ACK를 받아야 메모리에서 데이터를 제거하거나
- 중간에 유실이 발생하면 이를 재전송하는 기능이 있었다
- 그러나 이건 모두 TCP에 해당되는 내용이고 UDP에는 이런 기능이 없다

![](files/Pasted%20image%2020250303203348.png)

- 데이터 통신은 데이터 전송의 신뢰성이 핵심
- UDP는 데이터 전송을 보장하지 않는 프로토콜이므로 제한된 용도로만 사용된다.

- UDP는 음성 데이터나 실시간 스트리밍과 같이 시간에 민감한 프로토콜이나 애플리케이션을 사용하는 경우 사내 방송이나 증권 시세 데이터 전송에 사용되는 멀티캐스트처럼 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경에서 주로 사용된다.

- 신뢰성보다 일부 데이터가 유실되더라도 시간에 맞추어 계속 전송하는 게 중요한 화상회의 시스템 등에 UDP를 사용한다

- UDP는 TCP와 달리 통신 시작 전 3방향 핸드셰이크 과정처럼 사전에 연결을 확립하는 절차가 없다
- 그 대신 UDP에서는 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용되고 유실된다
- 그래서 UDP 프로토콜을 사용하는 애플리케이션이 대부분 이런 상황을 인지하고 동작하거나 연결 확립은 TCP 프로토콜을 사용하고 애플리케이션끼리 모든 준비를 마친 후 실제 데이터만 UDP를 이용하는 경우가 대부분이다.

- 같은 동영상 스트리밍이더라도 넷플릭스나 유튜브와 같이 시간에 민감하지 않은 단일 시청자를 위한 연결은 TCP를 사용한다
- 이 경우 원활한 시청을 위해 수 초~ 수 분의 동영상 데이터를 미리 받아놓고 네트워크에 잠시 문제가 생기더라도 동영상이 끊기지 않도록 캐시에 저장한다
- 하지만 실시간 화상 회의 솔루션의 경우 데이터 전송이 양방향으로 이루어지고, 시간에 매우 민감하게 반응하므로 UDP를 사용한다.

|TCP|UDP|
|---|---|
|연결 지향 (Connection Oriented)|비연결형 (Connectionless)|
|오류 제어 수행함|오류 제어 수행 안 함|
|흐름 제어 수행함|흐름 제어 수행 안 함|
|유니캐스트|유니캐스트, 멀티캐스트, 브로드캐스트|
|전이중 (Full Duplex)|반이중 (Half Duplex)|
|데이터 전송|실시간 트래픽 전송|

## 3.5 ARP
- 2계층 MAC 주소와 3계층 IP 주소는 아무 관계도 없다
- MAC 주소는 하드웨어 업체가 임의적으로 할당한 주소이고 NIC에 종속된 주소
- 3계층 IP 주소는 우리가 직접 할당하거나 DHCP를 이용해 자동으로 할당받는 값
- 실제로 통신은 IP 기반으로 일어나고 MAC 주소는 상대방의 주소를 자동으로 알아내 통신
- 이때 상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜이 ARP(Adress Resolution Protocol)

> IPv6에서는 NDP(Neighbor Discovery Protocol)를 사용하는 것 같아요

### 3.5.1 ARP란?
- IP 주소는 MAC 주소와 전혀 연관성이 없으므로 이를 연계시켜 주기 위한 메커니즘이 바로 ARP

![](files/Pasted%20image%2020250303204801.png)

- ARP 프로토콜은 TCP/IP 프로토콜 스택을 위해서만 동작하는 것은 아니다
- TCP-이더넷 프로토콜과 같이 3계층 논리적 주소와 2계층 물리적 주소 사이에 관계가 없는 프로토콜에서 ARP 프로토콜와 같은 메커니즘을 사용해 물리적 주소와 논리적 주소를 연결한다

- 호스트 사이에 아무런 통신이 없다가 처음 통신을 시도하면 패킷을 바로 캡슐화할 수 없다
- 통신을 시도할 때 출발지와 목적지 IP 주소는 미리 알고 있지만 상대방의 MAC 주소를 알 수 없어 2계층 캡슐화가 불가능하다
- 상대방의 MAC 주소를 알아내려면 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방의 MAC 주소를 질의해야 한다
	- NDP는 멀티캐스트를 사용해서 좀 더 효율이 좋다고 합니다

- ARP 브로드캐스트를 받은 목적지는 ARP 프로토콜을 이용해 자신의 MAC 주소를 응답
- 이 작업이 완료되면 출발지, 목적지 모두 상대방에 대한 MAC 주소를 학습하고 이후 패킷이 정상적으로 인캡슐레이션되어 상대방에게 전달될 수 있다.

- 패킷 네트워크에서는 큰 데이터를 잘라 전송하므로 여러 개의 패킷을 전송
- 패킷을 보낼 때마다 ARP 브로드캐스트를 수행할 수 없으므로 메모리에 캐싱해서 사용
- 성능 유지를 위해서는 ARP 테이블을 오래 유지하는 것이 좋지만 논리 주소는 언제든지 바뀔 수 있으므로 일정 시간 통신이 없으면 테이블은 삭제된다
	- 윈도우, 리눅스 15~45초
	- 맥 20분

- 네트워크 장비에서의 ARP 작업은 하드웨어 가속으로 처리되지 않고 CPU에서 직접 수행하므로 짧은 시간에 많은 ARP 작업이 들어오면 네트워크 장비에는 큰 부하로 작용
	- 그동안 해커들이 네트워크 장비를 무력화할 때 다량의 ARP을 이용한 공격을 많이 했다
	- 이런 공격에 대응하기 위해 네트워크 장비는 ARP 테이블 저장 기간을 일반 PC보다 길게 설정하고 많은 ARP 요청이 들어오면 이를 필터링하거나 천천히 처리하는 방식으로 장비를 보호
	- 일부 장비는 ARP 테이블을 수동으로만 갱신하도록 설정
		- 회선 사업자가 임대하는 네트워크 장비는 MAC 테이블이나 ARP 테이블을 정적으로 유지하기 때문에 외부 회선에 연결된 네트워크 장비가 변경된 경우 알려줘야 한다

- ARP 캐시 외에도 DNS 캐시, 라우팅 캐시등 여러 캐시 테이블을 네트워크에서 활용하고 있다.

### 3.5.2 ARP 동작
- ARP 패킷은 여러 가지 필드 중 ARP 데이터에 사용되는 송신자 MAC 주소, 송신자 IP 주소, 대상자 MAC 주소, 대상자 IP 주소 4개가 중요하다.

![](files/Pasted%20image%2020250303204801.png)

![](files/Pasted%20image%2020250303221717.png)

- 서버 A에서 B로 ping을 보내려고 할 때 서버 A에서는 목적지 MAC 주소를 모르므로 패킷을 만들 수 없다
- 서버 A는 목적지 서버 B의 MAC 주소를 알아내기 위해서 ARP 요청을 네트워크에 브로드캐스트한다.
- ARP 패킷을 네트워크에 브로드캐스트할 때 2계층 MAC 주소는 출발지를 자신의 MAC 주소로, 도착지는 브로드캐스트(FF-FF-FF-FF-FF-FF)로 채우고 ARP 프로토콜 필드의 전송자 MAC과 IP 주소에는 자신의 주소로, 대상자 IP 주소는 1.1.1.2로 대상자 MAC 주소는 00-00-00-00-00-00으로 채워서 네트워크에 뿌린다.
![](files/Pasted%20image%2020250303221854.png)

- 2계층 헤더에서 사용하는 출발지, 목적지 MAC 필드 외에 ARP 프로토콜에는 송신자, 대상자 MAC, IP 주소를 나타내는 필드가 있다
- ARP에서는 송신자(Sender), 대상자(Target)와 같은 다른 용어를 사용해 일반 패킷의 2, 3계층에서 사용하는 출발지, 도착지, 기존 MAC, IP 주소와 구분해서 표현한다

- ARP 요청은 브로드캐스트이므로 모든 단말에게 전달되는데 자신의 IP와 일치핮 않으면 패킷을 버린다
- 서버 B에서는 ARP 요청을 처리하고 응답을 보낸다.
- 이때 송신자와 대상자의 위치가 바뀐다.

- 서버 B는 ARP 요청을 수신하면서 ARP 요청을 보낸 서버 A의 IP 주소와 MAC 주소를 알고 있으므로 모든 ARP 필드를 채워 응답할 수 있다.
- 대상자 MAC, IP 주소를 채우고 자신의 MAC, IP 주소를 송신자 MAC, IP 주소로 채워 응답한다.

- ARP 요청을 처음 보낼 때는 브로드캐스트인 반면 ARP 응답을 보낼 때는 출발지와 도착지 MAC 주소가 명시되어 있는 유니캐스트다.

- 서버 A는 서버 B로부터 ARP 응답을 받아 자신의 ARP 캐시 데이블을 갱신한다.
- 이 ARP 캐시 테이블은 정해진 시간 동안 서버 B와의 통신이 없을 때까지 유지된다.
- 해당 시간 안에 통신이 다시 이루어지면 그 시간은 다시 초기화된다.

![](files/Pasted%20image%2020250303222226.png)

- ARP 캐시 테이블이 갱신된 후에는 상대방의 MAC 주소를 알고 있으므로 도착지 MAC 주소 필드를 채워서 ping 패킷을 보낼 수 있다.

### 3.5.3 GARP
- 일반적인 ARP 외에도 ARP 프로토콜 필드를 그대로 사용하지만 내용을 변경해 원래 ARP 프로토콜 목적과 다른 용도로 사용하는 경우도 있다.
- GARP, RARP

- Gratuitous ARP는 대상자 IP 필드에 자신의 IP 주소를 채워 ARP 요청을 보낸다
- GARP는 자신의 IP 주소와 MAC 주소를 알릴 목적으로 사용
- 따라서 목적지 MAC 주소 (2계층 MAC)에 브로드캐스트 MAC 주소를 쓴다.

- GARP 패킷을 살펴보면
- 송신자 MAC에는 자신의 MAC, 송신자 IP에는 자신의 IP 주소, 대상자 MAC 주소는 모두 0으로 표기하고, 대상자 IP 주소는 자신의 IP 주소로 보낸다.

- 다른 ARP 요청과 같은 점은 대상자 MAC 주소가 00:00:00:00:00:00으로 채워진 것이고 다른 점은 송신자와 대상자 IP 주소가 자신으로 동일하다는 것.

- GARP을 사용하는 이유는 3가지
	- IP 주소 충돌 감지
	- 상대방의 ARP 테이블 갱신
	- HA 용도의 클러스터링, VRRP(Virtual Router Redundancy Protocol), HSRP(Hot Standby Router Protocol)

#### 3.5.3.1 IP 주소 충돌 감지
- IP 주소는 유일하게 할당되어야 하는 값이지만 여러 가지 이유로 IP 주소가 충돌될 수 있다
- IP 충돌로 통신이 안 되는 것을 예방하기 위해 자신에게 할당된 IP가 네트워크에서 이미 사용되고 있는지 GARP로 확인한다.
- GARP에 대한 응답이 오면 네트워크상에서 해당 IP를 이미 사용 중인 단말이 있다는 것을 알 수 있다
- 윈도우의 경우 이런 응답을 받으면 사용자에게 IP 주소 충돌 에러 메시지를 보여준다.

#### 3.5.3.2 상대방(동일 서브넷에 있는)의 ARP 테이블 갱신
- 가상 MAC 주소를 사용하지 않는 데이터베이스 HA 솔루션에 주로 사용
- 데이터베이스 HA는 주로 두 데이터베이스 서버가 하나의 가상 IP 주소로 서비스한다.
- 두 대의 데이터베이스 중 한 대만 동작하고 나머지 한 대기는 대기하는 Active-Standby로 동작한다.

- 액티브 상태인 서버가 가상 IP 주소 요청에 응답해 서비스하지만 MAC 주소는 가상 주소가 아닌 실제 MAC 주소를 사용한다.

![](files/Pasted%20image%2020250303223138.png)

- ARP 요청을 받으면 Active 역할을 하는 DB-A가 ARP 요청에 응답한다.
- 오른쪽 그림처럼 마스터 장비가 동작하지 않는 경우 DB-B가 ARP 요청에 응답한다.
- 다만 기존 단말의 경우 ARP 테이블 캐시가 남아있으므로 이런 현상을 예방하기 위해 스탠바이 장비가 액티브 상태가 되면 GARP 패킷을 보내 액티브 장비가 변경되었음을 알려준다.

- 네트워크 장비가 아닌 데이터베이스에서 HA 기능을 제공하는 경우, 이런 형태의 기술을 많이 쓴다
- 이때 GARP를 여러 번 보내 로컬 네트워크 단말의 ARP 테이블을 확실하게 업데이트할 수 있게 해야한다.
- 현대 네트워크 장비에서는 이런 형태의 HA는 잘 쓰이지 않는다
- GARP를 이용해 패킷을 가로채는 기법이 많이 사용되어 보안상의 이유나 다른 운영상의 이유로 GARP를 받더라도 ARP 테이블을 갱신하지 않는 단말이 존재할 가능성이 있다.
- 따라서 이런 문제가 발생하지 않는 가상 MAC을 사용하는 HA 솔루션이 쓰인다.

#### 3.5.3.3 클러스터링, FHRP(VRRP, HSRP)
- 앞에서 다룬 HA 솔루션의 경우 장비 이중화를 위해 사용되지만 실제 MAC 주소를 사용하지 않고 가상 MAC 주소를 사용하는 클러스터링, VRRP, HSRP와 같은 FHRP(First Hop Redundancy Protocol)에서도 GARP가 사용된다.
- 데이터베이스 고가용성 솔루션에서 GARP 사용이 단말의 ARP 테이블을 갱신하는 것이 목적이었던 반면, 클러스터링이나 FHRP의 GARP 사용은 네트워크에 있는 스위치 장비의 MAC 테이블 갱신이 목적이다.

- VRRP(Virtual Router Redundancy Protocol), HSRP(Hot Standby Router Protocol)은 FHRP의 일종이다.
- 이 프로토콜은 디폴트 게이트웨이에 장애가 발생한 경우, 해당 네트워크에 속한 단말이 외부 네트워크와 통신할 수 없는 문제를 해결하기 위해 개발되었다
- 단독으로 경로 지정을 할 수 없는 PC는 디폴트 게이트웨이의 상태를 알 수 없으므로 두 대의 디폴트 게이트웨이 라우터가 한 대처럼 동작해 한 대에 문제가 생기더라도 다른 한 대에서 서비스를 지속할 수 있는 FHRP를 사용해야 한다.

- 클러스터링에서 가상 MAC 주소를 사용하는 경우, 단말은 ARP 정보를 가상 MAC 주소로 학습하므로 단말의 ARP 테이블을 갱신할 필요가 없다.
- 하지만 클러스터링 중간에 있는 스위치의 MAC 테이블은 마스터가 변경되었을 때 가상 MAC 주소의 위치를 적절히 찾아가도록 업데이트해야 하므로 마스터가 변경되는 시점에 MAC 테이블 갱신이 필요하다
- 따라서 슬레이브가 마스터로 역할이 변경되면 GARP를 전송하고, 스위치에서는 이 GARP를 통해 MAC 주소에 대한 포트 정보를 새로 변경해 MAC 테이블을 갱신한다.

![](files/Pasted%20image%2020250303223941.png)

- 클러스터링이나 HA 솔루션에서 빠른 시간 안에 Failover되지 않으면 고가용성 솔루션 자체의 문제인 경우도 있지만 GARP 받은 스위치가 MAC 테이블을 빨리 갱신해주지 않아 문제가 되는 경우도 많다
- HA 솔루션을 도입하는 경우 이런 부분들이 반드시 함께 고려되고 테스트되어야 한다
- 이 경우 HA 솔루션에서 GARP를 보내는 시간이나 횟수를 조절하거나 스위치와 연결된 포트를 순간적으로 리셋해 스위치의 MAC 테이블을 초기화시키는 기법을 사용하기도 한다.

### 3.5.4 RARP
- RARP는 Reverse ARP 줄임말
- 반대로 동작하는 ARP.
- GARP처럼 ARP 프로토콜 구조는 같지만 필드에 들어가는 내용은 다르고 원래 목적과 반대로 사용된다.

- RARP는 MAC 주소로부터 IP 주소를 얻는다.
- IP 주소가 정해져있지 않은 단말이 IP 할당을 요청할 때 사용
	- 내 MAC 주소는 알지만 IP가 아직 할당되지 않아 IP를 할당해주는 서버에 어떤 IP 주소를 써야 하는지 물어볼 때 사용
	- RARP는 과거에 네트워크 호스트의 주소 할당에 사용되었지만 제한된 기능으로 인해 BOOTP와 DHCP로 대체되어 사용되지 않는다.

## 3.6 서브넷과 게이트웨이
- 초기 네트워크는 모든 단말이 하나의 네트워크에 존재하는 로컬 네트워크(LAN)을 고려하여 설계되어 통신하는 방법이 매우 간단했다
- 인터넷 발달로 작은 LAN 네트워크가 하나의 큰 네트워크로 묶이면서 먼 거리에 있는 다른 LAN 간의 통신이 중요해졌다.

- 같은 네트워크 내 통신과 원격지 네트워크 간의 통신은 동작 방식이나 필요한 네트워크 장비가 다르다
- 원격지 네트워크 통신에 사용하는 장비를 게이트웨이라고 부르고
- 3계층 장비(라우터, L3 스위치)가 이 역할을 할 수 있다.

### 3.6.1 서브넷과 게이트웨이 용도
- 로컬 네트워크에서는 ARP 브로드캐스트를 이용해 도착지 MAC 주소를 학습할 수 있고 이 MAC 주소로 직접 통신할 수 있지만 원격 네트워크 통신은 네트워크를 넘어 전달되지 못하는 브로드캐스트 성질 때문에 네트워크 장비의 도움이 필요하다
- 이를 Gateway라고 한다
- Gateway 정보를 PC나 네트워크 장비에 설정하는 항목이 바로 기본 게이트웨이(Default Gateway)

![](files/Pasted%20image%2020250303225115.png)

- 기본 게이트웨이는 3계층 장비가 수행하고, 여러 네트워크와 연결되면서 적절한 경로를 지정해주는 역할을 한다

- LAN 통신과 외부 네트워크 통신은 방식이 다르므로 우선 목적지가 자신이 속한 네트워크 범위인지 확인하는 작업이 필요하다
- 이때 사용되는 것이 서브넷 마스크다
- 이를 이용해 목적지가 로컬 네트워크에 속하는지 알 수 있다.

- 프록시 ARP
	- Proxy ARP는 말 그대로 ARP를 대행해주는 기능이다
	- 원격지 통신은 기본 게이트웨이를 찾아 ARP 요청을 보내고 패킷을 기본 게이트웨이 쪽으로 보내야만 통신할 수 있다
	- 하지만 기본 게이트웨이에 프록시 ARP가 활성화된 경우, 원격지 통신이더라도 로컬에 ARP 브로드캐스트를 보내 통신할 수 있다
	- 프록시 ARP가 활성화된 기본 게이트웨이(라우터)는 ARP 브로드캐스트가 들어오면 자신이 대행해 ARP 응답을 해준다.
	- 이 경우, 패킷이 기본 게이트웨이 쪽으로 보내지므로 원격지 경로로 전달될 수 있다.
	- 프록시 ARP 기능은 라우터에 기본적으로 활성화되어있어 사용자 몰래 동작하는 경우가 많다
	- 프록시 ARP는 사용자 설정 없이 자동으로 동작해 편리한 것처럼 느껴지지만 네트워크 설정 오류가 있거나 꼭 입력해야 할 설정이 되어있지 않아도 동작해 장애가 발생했을 때 쉽게 해결하지 못하게 만들기도 한다
	- 원격지 통신인 경우 프록시 ARP가 활성화된 라우터가 운영되고 있다면 엉뚱한 ARP 요청도 받아 처리해주므로 PC에서 기본 게이트웨이가 잘못 입력되어 있어도 통신이 되는 경우가 발생할 수 있다
	- 평소에는 프록시 ARP 기능으로 문제가 없다가 라우터를 교체하거나 라우터 구성을 바꾸면 장애가 발생한다.

### 3.6.2 2계층 통신 vs 3계층 통신
- 2계층 통신, 3계층 통신은 원래 정확한 표현은 아니지만 실무에서 많이 쓰는 표현이다.
- 정확한 표현은 로컬 네트워크 통신, 원격지 네트워크 통신이다
- 단말 간의 통신은 애플리케이션 계층부터 시작해 캡슐화, 디캡슐화를 거쳐 통신하는데 로컬 네트워크에서 직접 통신하는 경우 라우터 같은 3계층 네트워크 장비 도움 없이 통신이 가능하다
- 즉, 단말 간을 연결해주는 네트워크 장비에서 2계층까지만 정보를 확인해 통신하고 ARP 요청을 보낼 때 직접 브로드캐스트를 이용하므로 L2 통신이라고 부른다.

- 반면 원격지 네트워크와 통신해야 할 경우 라우터와 같은 3계층 장비 도움 없이는 통신할 수 없다
- 해당 패킷을 전송하는 네트워크 장비에서 3계층 정보까지 확인해야 하며 이것을 L3 통신이라고 한다

![](files/Pasted%20image%2020250303225940.png)

- 통신하는 출발지와 도착지의 네트워크가 같다와 다르다는 조건에 따라 통신 방식이 달라지는데 이런 차이는 로컬과 리모트 통신을 위한 ARP 동작 방식이 다른 것에 의해 발생한다

![](files/Pasted%20image%2020250303230125.png)

- 로컬 네트워크 통신은 직접 이루어진다
- 상대방의 MAC 주소를 알아내기 위해 ARP 브로드캐스트 보내고, 상대방의 MAC 주소 알아내자마자 통신이 이루어진다

- 외부 네트워크와의 통신이 필요할 때는 단말이 자신이 직접 보낼 수 없는 위치에 목적지가 있다고 판단하고 ARP 요청을 기본 게이트웨이의 IP 주소로 요청한다.
- 게이트웨이에서 ARP 응답을 받은 단말은 도착지 MAC 주소에 게이트웨이 MAC 주소를 넣고 통신을 시작한다.

![](files/Pasted%20image%2020250303230157.png)

- 로컬 통신은 도착지 MAC 주소와 도착지 IP 주소가 같은 반면 원격지 통신은 도착지 MAC 주소와 도착지 IP 주소가 다르다

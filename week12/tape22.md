
### 부하분산이란

 가용성을 위해 서버를 여러 대 두게 되면서 서비스 요청이 오면 서버에 서비스 요청을 분산하는 방식으로 부하를 분산한다.

- 사용자는 하나의 가상 ip (VIP)를 통해 서버로 접근하고,
- 로드밸런서는 각 서버의 상태를 체크해서 서비스 가능한 서버로만 요청을 분산하는 방식
- 방화벽을 이중화할 때 active-active 로 구성하기 위해 로드밸런서를 사용하기도 한다. (FWLB)
    - 비대칭 경로와 같은 구조에서 방화벽은 자신을 통과하지 않은 응답패킷이 들어오면 drop 시키기 때문에, FWLB를 사용해서 방화벽 세션을 분산시키고 한 번 방화벽을 지나간 세션이 다시 같은 방화벽을 거치도록 트래픽을 분산한다.

로드밸런서는 서비스를 제공하는 가상 IP (VIP)가 있고, real IP를 바인딩하여 요청을 전달하는 방식으로 부하를 분산하는데,
<img width="596" alt="Screenshot 2025-05-22 at 8 55 09 PM" src="https://github.com/user-attachments/assets/8d134928-ce0d-405a-a7cd-75680f1ab160" />

- 로드밸런서는 부하분산 그룹을 만들 때 ip 주소와 더불어 4계층의  port 정보까지 지정한다.
- 그래서 로드밸런서를 보통 L4 스위치라고 부른다.


**헬스체크 방식**

로드밸런서는 각 서비스를 주기적으로 헬스체크해서 비정상적인 서버는 서비스 그룹에서 제외하여 트래픽을 보내지 않는다.

- 제외된 후에도 헬스체크를 통해서 정상으로 돌아오면 다시 그룹에 추가하여 트래픽을 처리

1. ICMP
    - VIP에 연결된 리얼 서버에 대해 ICMP(ping)로 헬스체크
2. TCP 서비스 포트
    - 로드밸런서에 설정된 서버의 서비스 포트를 확인
    - 서비스 포트가 2000번으로 등록 → realIP 의 2000번대 포트로 SYN를 보내고 ACK를 받는 방식으로 헬스체크한다.
    - 다만 이런 헬스체크로 인한 부하를 줄이거나 세션을 더 빨리 끊기 위해서 TCP Half Open 방식을 사용하는데,
    - 초기의 3way 핸드쉐이크와 동일하게 SYN → SYN/ACK 를 받고 이후에 ACK 대신 RST를 보내 세션을 종료하는 방식이다.
3. HTTP 상태코드
    - TCP는 정상적으로 열려있어도, 서비스 응답을 정상적으로 해주지 못하는 경우를 체크
    - 상태코드를 200을 응답하는지 여부를 확인
4. 문자열 확인
    - 서버로 콘텐츠를 요청하고, 응답받은 내용이 정상적으로 내려왔는지 여부로 헬스체크하는 방법
    - 보통 특정 웹페이지를 호출해 사전에 지정한 문자열이 웹페이지 내 포함되어있는지 등을 체크하는 기능이다.
    - 서버의 백엔드 상태까지 확인이 가능

**헬스체크 주기와 타이머**

헬스체크 주기는 아래와 같은 고려사항이 있다.

- 주기 (Interval)
    - 로드밸런서 → 서버로 헬스체크 패킷을 보내는 주기
- 응답시간 (Response)
    - 로드밸런서 → 서버로 패킷을 보내고 응답을 기다리는 시간.
    - 해당 시간까지 응답이 오지 않으면 실패
- Retries
    - 헬스체크 실패 시 최대 시도 횟수
    - 최대 시도횟수 이전에 성공하면 이 숫자는 초기화된다.
- Timeout
    - 헬스체크 실패 시 최대 대기시간
- Dead Interval
    - 서비스 다운 시의 헬스체크 주기
    - 서비스가 죽은 상태에서 헬스체크 주기를 별도로 더 늘릴 때 사용


<img width="890" alt="Screenshot 2025-05-22 at 9 00 20 PM" src="https://github.com/user-attachments/assets/71ae32d7-67c9-4266-b9ac-8d394e093c5f" />
- 로드밸런서 → 서버로 헬스체크 패킷을 보내는 시점 간격

- 마름모는 서버의 응답을 기다리는 시간
    - 이 시간 내 응답이 오지 않으면 실패처리한다.
   - 응답 시간은 interval보다 더 짧아야한다. (헬스체크 보내는 주기가 응답시간보다는 길어야함)

---

### 부하분산 알고리즘

- 로드밸런서는 리얼서버로 부하를 분산할 때, 사전에 정해진 알고리즘을 통해서 진행한다.
<img width="901" alt="Screenshot 2025-05-22 at 9 00 48 PM" src="https://github.com/user-attachments/assets/275564f7-96d6-42dc-beb8-82bee6ed3a82" />



**라운드 로빈**

- 특별한 규칙 없이 구성된 장비를 순차적으로 돌아가면서 트래픽을 분산하는 알고리즘
- 순차적으로 모든 장비에 분산하기 때문에 모든 장비의 총 누적 세션 수는 동일해진다.

<img width="889" alt="Screenshot 2025-05-22 at 9 01 05 PM" src="https://github.com/user-attachments/assets/78af0a6b-365c-4a8e-b5c1-1a66dbe6ea9c" />



**최소접속 방식**

- 서버가 가진 세션 부하를 확인하고, 그것에 맞게 부하를 분산하는 방식
- 로드밸런서에는 서비스 요청을 보낼 때마다 세션 테이블이 생성되기 때문에 각 장비에 연결된 세션 수를 확인할 수 있음
- 장비 별 세션 수를 확인해서 가장 적게 연결된 장비로 요청을 보내는 방식

⇒ 부하는 고르게 분산할 수 있으나 요청이 항상 같은 서버로 가지 않으므로 세션을 유지해야하는 서비스에서는 정상적으로 동작하지 않게 됨.

- 예를 들어 장바구니처럼 A 서버에 상품을 담았는데 조회를 B 서버에서 하면 보이지 않는 문제가 발생할 수도 있음
- 그래서 라운드로빈, 최소접속 방식을 사용하면서  sticky ooption 을 통해 한 번 접속한 커넥션을 유지하는 방식도 사용한다.

**해시**

- 클라이언트가 같은 서버에 지속적으로 접속하기 위해 사용하는 부하분산 방식
- 해시 알고리즘을 통해 얻은 결괏값으로 어떤 장비에 요청을 보낼 지 결정한다.
- 하지만 부하를 고려하지 않게 되기 때문에 한 쪽으로 요청이 몰릴 수 있다.

---

### 로드밸런서

로드밸런서의 구성 방식은 구성 위치에 따라 2가지로 분류된다.

실질적으로는 서버로 가는 트래픽이 모두 로드밸런서를 경유하는지, 혹은 경유하지 않아도 되는지에 대한 트래픽 흐름으로 구분된다.

<img width="913" alt="Screenshot 2025-05-22 at 9 01 37 PM" src="https://github.com/user-attachments/assets/c53507d9-c276-4771-9c88-88b926101f38" />


- **One-Arm 구성**
    - 로드밸런서가 중간 스위치 옆에 연결되는 구조
    - 서버의 트래픽이 로드밸런서를 경유하지 않을 수도 있으며, 로드밸런서를 경유하는지 여부는 부하분산을 이용한 트래픽인지 여부로 구분할 수 있다.
    - 부하분산을 이용하는 트래픽의 경우
        - 해당 서비스 ip 정보를 로드밸런서가 가지고 있어서, 트래픽이 유입되면 로드밸런서를 거침
        - 트래픽과 응답 모두 로드밸런서를 거치려면 로드밸런서가 가진 ip로 sourceNAT도 함께 이루어지거나, DSR을 사용해야한다.
    - 부하분산을 이용하지 않는 경우에도 서버 통신이 가능하기 때문에, 불필요한 트래픽이 로드밸런서에 유입되지 않는다는 것이 장점
    - 대역폭이 부족할 때 스위치-로드밸런서 구간만 증설하면 되므로 상대적으로 확장에 유리
<img width="894" alt="Screenshot 2025-05-22 at 9 01 48 PM" src="https://github.com/user-attachments/assets/ebb5f57b-4422-4f7b-b8e6-6fdbfd44c888" />



- Inline 구성
    - 서버로 흐르는 모든 트래픽이 로드밸런서를 통과한다.
    - 아무래도 원암보다는 로드밸런서에 부하가 갈 수 있으므로 로드밸런서의 성능과 패킷 throughput  성능을 구별해서 디자인해야한다.

> 물리적으로는 원암 구성이지만 논리적으로는 인라인 구성인 경우도 있다.
VRF나 VLAN 처럼 가상화를 이용하는 경우 인라인으로 구성되기 때문에, 물리 장비만 보고 구분하면 안된다.
> 

**구성방식**

1. **트랜스패런트 모드**
    1. 로드밸런서가 OSI 2계층 스위치처럼 동작하는 구성으로,
    2. 로드밸런서에 서비스하기위해 사용하는 VIP 주소와 실제 서버가 동일한 네트워크 구성
    3. 트랜스패런트 구성에는 로드밸런서를 지나도 부하분산 서비스를 받는 트래픽인 경우에만 4계층 이상의 기능을 수행하고, 아니면 L2 스위치 기능을 수행한다.

<img width="900" alt="Screenshot 2025-05-22 at 9 02 01 PM" src="https://github.com/user-attachments/assets/20bc605a-80a7-4cc0-90de-05fe1833da01" />


- 서비스 ip인 로드밸런서의 VIP 주소로 서비스가 요청 들어오면
- 목적지 ip 주소를 VIP에 바인딩하고 실제 ip 주소로 변경된다.
- 이 때 네트워크 대역이 동일하므로  L3 장비를 지날 때 mac 주소가 별도로 변경되진 않는다.

<img width="888" alt="Screenshot 2025-05-22 at 9 02 16 PM" src="https://github.com/user-attachments/assets/21e5d828-f3bd-427d-b72f-c41b0b0db98a" />


- 반대로 응답이 로드밸런서 지날 때 출발지 ip 주소가 VIP 주소로 변경되는데,
- 목적지 mac 주소가 이미 게이트웨이의  mac 주소를 갖고 있어서 변경하지않는다.

1. **라우티드 모드**
    1. 로드밸런서가 라우팅 역할을 수행하며,
    2. 로드밸런서를 기준으로 client와  server가 **다른 네트워크로 분리**된 경우의 구성이다.

<img width="919" alt="Screenshot 2025-05-22 at 9 03 11 PM" src="https://github.com/user-attachments/assets/78c6381f-f6ec-47fa-8bf4-2a360ae27642" />


- 서비스 ip인 VIP로 서비스를 요청하면, 목적지  IP 와 출발/목적지  mac이 변경되고,
- mac이 변경된 패킷은 라우팅 테이블을 확인해 실제 서버로 전송된다.
- 그리고 이 과정에서 과정에서 로드밸런서는 VIP→ RealIP로 주소를 변경하니까 Destination NAT 가 되는 셈
- 응답 패킷도 서버 ip 가 출발지가 되어서 로드밸런서를 거치는데,
- 로드밸런서로 들어온 패킷은 출발지 ip 주소를 VIP로 바꾸고 mac 주소도 변경한 뒤 응답패킷을 전송한다.
<img width="879" alt="Screenshot 2025-05-22 at 9 03 28 PM" src="https://github.com/user-attachments/assets/3ab212e3-89be-4b8a-8e92-fa2b0f8a6efe" />
<br>

1. **DSR 모드**
    1. 요청이 로드밸런서를 통해 들어오지만, 응답은 서버가 사용자에게 직접 하는 모드
    2. 응답 시 로드밸런서를 경유하지 않으므로 **원암 구성**
    3. L2 DSR은 실제 서버 네트워크를 로드밸런서가 가진 경우이고, L3 DSR은 가지지 않은 경우로,
        1. 로드밸런서가 실제 서버까지 통신하는 것이 L2,L3냐에 따라 나뉜다.
    4. 스트리밍 서비스같이 응답패킷 트래픽이 대역폭 대부분을 차지하는 경우 DSR로 로드밸런서 부하를 감소한다.

<img width="889" alt="Screenshot 2025-05-22 at 9 03 45 PM" src="https://github.com/user-attachments/assets/370df6cd-5c8d-45cc-b026-889b435f7e95" />


- DSR 모드는 로드밸런서를 거치지 않고 응답해야하므로 로드밸런서를 통해서 출발지 ip를 변경하는 source NAT 수행이 불가능
- 사용자는 서비스 VIP가 아니라 realIP로 응답을 받아서 패킷이 정상처리되지 않는다.
- 그래서 DSR 모드는 VIP 그대로 유지하고 목적지 mac 주소만 실제 서버 mac 주소로 변경해서 전송한다.
- 서버는 루프백 인터페이스를 통해서 VIP 주소를 할당해서, 루프백에 설정된 ip 주소더라도 패킷을 수신할 수 있도록 해결
<img width="732" alt="Screenshot 2025-05-22 at 9 04 05 PM" src="https://github.com/user-attachments/assets/20e88ae4-0f93-4809-a7aa-caaa5449bba6" />


- 그래서 DSR 모드를 사용하려면 루프백 인터페이스 설정과, 리눅스 커널 파라미터 수정이 필요하다.


<br>

**유의사항**

**원암 구성의 동일 네트워크 사용 시**

- 요청은 VIP → realIP 로 Destination NAT를 한 후 서버로 전달하는데,
- 응답할 때 로드밸런서를 거치지 않고 응답하면 ip가 달라져서 폐기되는 문제가 발생할 수 있다.

<img width="772" alt="Screenshot 2025-05-22 at 9 04 34 PM" src="https://github.com/user-attachments/assets/23c5c2d4-c029-4b42-b9e3-a13e288e88c1" />


- 그래서 게이트웨이를 로드밸런서로 설정해서, 외부 사용자 호출 응답은 항상 로드밸런서(게이트웨이)를 통하므로 응답이 가능해진다.
- 또한 source NAT를 적용해서 로드밸런서가 요청을 한 것처럼 출발지 ip주소를 변경하면, 응답도 로드밸런서로 가서 다시 목적지 ip 주소가 로드밸런서를 호출한 사용자 ip로 바뀌어 응답이 가능하다.
- 마지막으로는 DSR도 사용가능한데, 루프백 인터페이스가 설정되어있으므로 바로 서버에 응답을 내려줄 수 있다.

**동일 네트워크 내 VIP 호출**

- 서버 2가 다른 서버를 호출하기 위해 로드밸런서에게 서비스 요청을 하면,
- 응답을 주는 서버는 동일 네트워크임을 확인하고 로드밸런서를 거치지 않고 응답하게된다.
- 이러면 서버 2는 최초 요청한 ip주소가 아니어서 패킷을 드롭하는 현상이 발생할 수 있는데, 이는 원암/인라인 모두 발생이 가능하다.

<img width="772" alt="Screenshot 2025-05-22 at 9 04 49 PM" src="https://github.com/user-attachments/assets/222c1dce-086c-400d-9a44-0168afd81eb0" />


- 이는 서비스 요청이 로드밸런서를 거칠 때 출발지 주소를 로드밸런서 ip로 바꾸는 sourceNAT를 사용하거나,
- DSR 모드를 사용해 로드밸런서를 거치지 않고 직접 응답하면 된다.

**HAProxy를 사용한 로드밸런서 설정**

- HAProxy는 기존 하드웨어 로드밸런서 역할을 일반 서버에서 수행하게 해주는 오픈소스 기반 SW 로드밸런서로,
- 일종의 NFV로 볼 수 있다. (network Function Virtualization)
- 클라우드 환경에서 로드밸런서로 사용하기 적합하며, 쿠버네티스 ingress controller 역할도 수행한다.

- HAProxy는 haproxy.cfg 파일에 기본 속성, 부하분산 설정을 하고 해당 값을 불러와서 구동된다.
- 해당 설정파일은 프로세스 전반에 사용되는  global 섹션, 실제 로드밸런서 수행을 위한 defaults, listen, frontend, backend 섹션으로 나뉘어져있다.

<img width="779" alt="Screenshot 2025-05-22 at 9 05 04 PM" src="https://github.com/user-attachments/assets/ec6df5c4-aa48-4914-9b51-0c06955cfdb5" />


- global : HAProxy 전반에 적용되는 설정값
    - log, daemon, maxconn 등
- defaults: listen 이나 backend 섹션에 별도 설정이 없을 때 사용하는 값
    - mode, timeout, maxconn 등 값을 지정할 수 있다.
- frontend : 실제 서비스에 사용될 가상 IP 설정
    - bind : 가상IP에 사용될 서비스 IP
- backend : 가상 IP에 전달되어 실제 서비스에 사용되는 real IP 설정
- listen : frontend, backend 동시 설정이 가능한 섹션
    - 프론트와 백을 나누어서 설정할 필요가 없이 가상 IP와 realIP가 같을 때는  listen 섹션으로만 설정이 가능하다.
 
<br>

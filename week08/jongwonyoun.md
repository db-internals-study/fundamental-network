```toc
```

# 서버 네트워크 기본
- 서버 내부 설정이지만 네트워크와 직접 관련이 있고, 네트워크에도 영향을 미칠 수 있는 서버의 네트워크 설정을 다룬다
- 윈도우와 리눅스에서 네트워크를 각각 어떻게 설정하고, 현재 네트워크 상태를 어떻게 확인할 수 있는지 다룬다

## 8.1 서버의 네트워크 설정 및 확인
- 가장 기본적인 네트워크 설정은 IP 주소, 서브넷, 게이트웨이, DNS IP 주소
- 서버뿐만 아니라 네트워크에 연결하려는 모든 장비는 이런 정보가 필요
- 이게 번거로우니 자동으로 설정해주는 DHCP 사용

### 8.1.1 리눅스 서버 네트워크
- 일반적으로 리눅스는 설정 파일이 텍스트 파일

#### 8.1.1.1 CentOS의 네트워크 설정
- `/etc/sysconfig/network-scripts`에 설정 파일 존재
- 여기에는 `ifcfg-eth0`, `eth1`과 같은 설정 파일과 인터페이스 up, down 같은 인터페이스 전용 제어 스크립트가 있다
- 각 인터페이스 설정은 모든 인터페이스의 설정 정보를 쓰지 않고 인터페이스별 설정 파일로 관리

![](files/Pasted%20image%2020250412145603.png)

| 항목        | 설명                                |
| --------- | --------------------------------- |
| ONBOOT    | 부팅 시 인터페이스를 활성화시킬 것인지 결정(yes/no)  |
| BOOTPROTO | 부팅 시 사용할 프로토콜(none, dhcp, static) |
| IPADDR    | IP 주소                             |
| NETMASK   | 서브넷 마스크 예: 255.255.255.0          |
| PREFIX    | 서브넷 마스크(비트 갯수로 표기) 예: 24          |
| GATEWAY   | 게이트웨이 주소                          |
| DNS1      | 주 DNS 정보 입력                       |
| DNS2      | 보조 DNS                            |

![](files/Pasted%20image%2020250412145609.png)

- ONBOOT는 부팅 시 해당 인터페이스를 활성화 상태로 쓸 건지, 비활성화 상태로 쓸 건지 결정
- no로 되어있다면 네트워크에 기본적으로 연결되지 않는다.

- BOOTPROTO는 부팅 시 사용할 프로토콜 지정. none, static, dhcp

- DEFROUTE는 default route를 줄인 거로, 디폴트 라우팅 쓸지 결정
- yes, no로 선택하고 기본은 yes

- IP ADDRESS는 서버에서 사용할 IP 주소.
- PREFIX는 서브넷 마스크를 비트로 기입
- GATEWAY, DNS는 각각 게이트웨이 주소와 DNS 서버 주소

- MACADDR, NAME, UUID 등 여러 설정이 더 있지만 설정하지 않아도 상관없다
- 하드웨어 종속적인 값이므로 네트워크 어댑터 등 하드웨어가 바뀌면 수정해야 한다.

- 리눅스에서는 인터페이스 파일 수정해도 즉시 적용되지 않고, 네트워크 서비스를 재시작하거나 인터페이스를 재시작해야 한다.
	- 네트워크 서비스 재시작하면 모든 인터페이스 및 전체 네트워크 서비스 재시작
	- 대신 특정 인터페이스만 재시작 가능
	- 단, `ifdown`으로 인터페이스 재시작하면 해당 인터페이스 네트워크가 끊기므로 다른 인터페이스로 접속하거나 콘솔 상태에서 작업
	- 단, 네트워크 서비스의 경우 원격상에서 수행할 때 보통 잠시 지연만 발생하고, 원격이 끊기지는 않지만 재시작이 오래 걸리면 원격 접속이 끊길 수 있으니 유의

```
# systemctl restart network.service

# ifdown ifcfg-eth0
# ifup ifcfg-eth0
```

![](files/Pasted%20image%2020250412150339.png)

- 현재 인터페이스 정보 보려면 `ifconfig` 사용
	- IP 주소, 서브넷, 게이트웨이, MTU, 송수신되는 패킷 수, 에러 패킷 등 다양한 정보 확인 가능
	- 만약 명령어 없다면 `net-tools` 설치

![](files/Pasted%20image%2020250412150347.png)

- 혹은 `ip address`로 비슷한 네트워크 정보 확인 가능

- `ip -s link`로 인터페이스로 송수신된 패킷 정보 확인 가능

#### 8.1.1.2 우분투의 네트워크 설정
- CentOS랑 비슷
- 네트워크 설정은 `/etc/network/interfaces`에 존재
- 여기에도 인터페이스 관련 파일과 디렉터리, 스크립트 등 있음

![](files/Pasted%20image%2020250412150914.png)

- 우분투는 `interfaces` 설정 파일에 모든 인터페이스 설정이 들어감

- 네트워크 서비스 재시작은 아래처럼

```
$ /etc/init.d/networking start
$ /etc/init.d/networking stop
$ /etc/init.d/networking reload
$ /etc/init.d/networking restart
$ /etc/init.d/networking force-reload
```

### 8.1.2 윈도 서버 네트워크

## 8.2 서버의 라우팅 테이블
- 서버도 외부 네트워크와 통신하기 위해 라우팅 테이블 가지고 있음
- 별도 설정하지 않아도 네트워크 정보 설정할 때 IP, 서브넷 마스크, 기본 게이트웨이 IP 주소 입력
- 이때 디폴트 라우팅이 라우팅 테이블에 자동으로 등록
- 덕분에 네트워크 기본 설정만 해도 내부 네트워크뿐만 아니라 외부 네트워크까지 통신 가능

- 단, 여러 개의 네트워크 어댑터를 사용하면 여러 가지 고려할 게 생긴다
- 아무 설정 없이 정상적으로 통신할 수도 있지만, 구성과 동작 방식에 대한 이해가 필요하다.

![](files/Pasted%20image%2020250412151323.png)

- 두 네트워크 어댑터에 모두 디폴트 게이트웨이 설정을 하면 정상적으로 통신이 되지 않는다
- 외부 공인망 네트워크와 통신하는 쪽에만 디폴트 게이트웨이 설정하고, 다른 어댑터에는 별도 라우팅 정보 입력 필요하다.

![](files/Pasted%20image%2020250412151424.png)

- 단, 하이퍼바이저가 설치된 가상화 서버에서는 하나의 물리 서버안에서 공인망 가상 머신과 사설망 가상 머신을 모두 운용해도 이런 라우팅 설정을 고민할 필요가 없다.
- 가상 서버 안에서 별도의 분리된 장비처럼 동작하기 때문
- 단, 하나의 가상 머신에서 공인망 논리 네트워크 카드와 사설망 공인 네트워크 모두 할당한 경우 라우팅 테이블 조정이 필요하다.

### 8.2.1 서버의 라우팅 테이블
- 서버의 라우팅 테이블 확인하면 보통 다음 항목을 출력

![](files/Pasted%20image%2020250412151820.png)

- 목적지 네트워크, 서브넷은 목적지 IP 주소에 맞는 라우팅 선택하는 기준
- 만약 `10.10.20.10`이라면 위 라우팅 테이블의 목적지 네트워크 범위가 `10.10.20.0~255`이므로 위 라우팅을 적용한다.

- 게이트웨이는 선택된 목적지로 가기 위해 서버에서 선택하는 넥스트 홉
- 목적지가 로컬 네트워크라면 연결됨(`connected`)이라고 뜨고 리모트 네트워크라면 해당 네트워크의 게이트웨이 설정
- 두 개 이상의 네트워크 카드가 있다면 원하는 네트워크 카드의 게이트웨이로 지정

- 인터페이스는 서버의 네트워크 카드
- 라우팅에서 어떤 물리적인 경로로 패킷을 보낼지 결정
- 인터페이스는 게이트웨이의 IP 주소 대역에 속하므로 게이트웨이 IP 주소 대역이 포함된 인터페이스를 지정

- 우선순위는 동일한 라우팅 테이블 두 개 이상 존재할 때 어떤 라우팅 테이블 선택할지 결정
- 낮을수록 우선순위가 높음

### 8.2.2 리눅스 서버의 라우팅 확인 및 관리
- `ip route`로 확인 가능

![](files/Pasted%20image%2020250412152835.png)

- `netstat` 명령에 `r` 옵션 추가하면 라우팅 테이블 편하게 확인 가능

![](files/Pasted%20image%2020250412152929.png)

- 여기에 `n` 옵션 추가로 사용하면 실제 IP도 보여서 좀 더 직관적인 확인 가능

![](files/Pasted%20image%2020250412153005.png)

- `netstat` 명령이 서버 엔지니어에게 익숙하지만 메트릭 값 등은 `ip route`에서만 확인 가능하므로 적절히 선택 필요

- 인터페이스가 하나라면 서버에 라우팅 테이블을 추가하거나 삭제할 필요가 거의 없다
- 동일 네트워크는 로컬 통신을 하고, 다른 원격지 네트워크에서는 디폴트 라우팅으로 게이트웨이로 지정된 인터페이스로 전송하면 된다
- 인터페이스가 두 개 이상이라면 어떤 네트워크 인터페이스를 사용해 패킷을 전송할지 명시해줘야 하는 경우가 있다
- 이때는 라우팅 테이블 수정하거나 삭제 필요

```
route add { -host | -net } Target[/prefix] [gw Gw] [metric M] [[dev] If]
```

- 추가하려는 목적지 IP나 네트워크 대역 입력하고 보낼 게이트웨이 지정
- 우선순위를 부여해 목적지에 대한 게이트웨이를 Active-Standby 형태로 구성하는 것도 가능
- 이때 메트릭 값을 이용해 라우팅 테이블의 우선순위 조정도 가능
- 액티브 경로에 문제가 발생하면 라우팅 테이블에서 해당 경로가 삭제되어 스탠바이로 통신이 Failover된다.

![](files/Pasted%20image%2020250412153414.png)

![](files/Pasted%20image%2020250412153421.png)

- 이 외에도 다양한 옵션이 있다
- 라우팅 테이블은 `ip` 명령어로도 추가/삭제 가능

```
route del { -host | -net } Target[/prefix] [gw Gw] [metric M] [[dev] If]
```

- 라우팅 삭제는 추가와 거의 비슷
- 디폴트 라우팅이 삭제되거나 설정되지 않으면 원격지 네트워크 통신은 불가능하고 네트워크 카드가 속한 로컬 통신만 가능

```
# route del -host 10.10.10.10 gw 10.1.1.1
# route del -net 10.10.10.0/24 dev eth0
# route del -net 10.10.10.0/24 gw 10.1.1.6 metric 20
```

- 디폴트 라우팅 설정은 목적지 네트워크를 `default`로 표기해 설정하는 것도 가능

```
# route add default gw 10.1.1.1 dev eth0  # 디폴트 라우팅 추가
# route del default gw 10.1.1.1 dev eth0  # 디폴트 라우팅 삭제
```

- 단, 이렇게 명령어로 입력된 라우팅 정보는 서버가 재부팅하면 사라진다
- 영구적인 라우팅 설정을 위해서는 별도 파일에 라우팅 설정 입력

#### 8.2.2.1 CentOS의 영구적 라우팅 설정
- `/etc/sysconfig/network-scripts/route-장치명`
- `eth0` 인터페이스에 대한 라우팅 설정은 `route-eth0`

- 라우팅 설정 파일에는 `ADDRESS`, `NETMASK`, `GATEWAY` 항목 사용
- 라우팅 테이블을 여러 개 설정할 때 각 항목 뒤에 숫자를 순서대로 붙인다

```
ADDRESS0=10.10.10.0
NETMASK0=255.255.255.0
GATEWAY0=10.1.1.1
ADDRESS1=10.10.20.0
NETMASK1=255.255.255.128
GATEWAY1=10.1.1.1
```

- 혹은 라우팅 테이블 형식과 유사하게 설정도 가능

```
10.10.10.0/24 via 192.168.0.1 dev eth1
```

- 이렇게 설정한 라우팅은 바로 적용되지는 않고 서버 재부팅하거나 네트워크 서비스 재시작 필요

#### 8.2.2.2 우분투의 영구적 라우팅 설정
- 우분투는 CentOS와 달리 별도 설정 파일이 없고 네트워크 설정에서 사용했던 `interfaces` 파일에 라우팅 설정

```
up route add [-net|-host] <host/net>/<mask> gw <host/IP> dev <Interface>
```

- `up`은 인터페이스가 시작될 때 실행되는 것으로 CentOS와 마찬가지로 네트워크를 다시 시작하거나 서버를 재부팅하는 경우, 신규 라우팅 정보가 라우팅 테이블에 등록

```
# eth0 네트워크 설정
auto eth0

# eth0 정적 네트워크 설정
iface eth0 inet static
    address 10.1.1.6
    netmask 255.255.255.0
    gateway 10.10.10.1
    dns-nameserver 219.250.36.130

# 영구적 라우팅 등록
# 10.10.10.0/24 가 목적지인 경우 , 게이트웨이인 10.1.1.1 로 라우팅
up route add -net 10.10.10.0 netmask 255.255.255.0 gw 10.1.1.1
```

### 8.2.3 윈도 서버의 라우팅 확인 및 관리

## 8.3 네트워크 확인을 위한 명령어

### 8.3.1 ping(Packet InterNet Groper)
- 네트워크 확인할 때 가장 많이 사용하는 명령어
- IP 네트워크를 통해 특정 목적지까지 네트워크가 잘 동작하고 있는지 확인하는 네트워크 명령어
- 상대방 호스트 살아있는지 확인하는 것이 최대 목표지만, 라우팅 경로가 정상적으로 구성되어있는지 확인할 때도 쓰인다.
- ICMP(Internet Control Message Protocol) 프로토콜 사용하고, ICMP 제어 메시지를 통해 여러 가지 네트워크 상태 파악

```
ping [옵션] 목적지_IP 주소
```

- 더 상세하게는 ping 체크 횟수, 데이터 크기 등 지정 가능
- 별도 옵션 없이 ping 체크하는 걸 '기본 ping'이라고 하고, 옵션을 사용해 체크하는 걸 '확장 ping'이라고 한다.
- 출발지 IP 지정도 가능

- 기본은 나가는 인터페이스에 지정된 IP가 출발지 IP로 지정
- 옵션을 사용해 루프백 인터페이스 IP나 다른 인터페이스 IP도 지정 가능
- 이를 '소스 ping'이라고 한다.

| 주요 옵션         | 설명                                                                                                                              |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| -c count      | ping을 보내는 패킷(ECHO_REQUEST)을 몇 번 보낼 것인지를 지정. 기본 설정은 종료(CTRL+C)할 때까지 패킷을 지속적으로 보냄.                                                |
| -i interval   | 패킷을 보내는 시간 간격. 기본 설정값은 1초. 슈퍼 유저의 경우, 0.2 이하로 설정 가능.                                                                            |
| -I interface  | 패킷을 보낼 때, 출발지 주소를 지정하거나 인터페이스 이름을 지정하면 출발지 주소가 변경됨. 이 옵션을 사용하지 않는 경우, 라우팅 테이블에 의해 나가는 인터페이스(Outgoing-Interface)의 IP 주소가 출발지가 됨. |
| -s packetsize | 패킷 크기를 지정. 기본 설정값은 56바이트(8바이트의 ICMP 헤더가 추가로 붙어 64바이트를 송신).                                                                      |

### 8.3.2 tcping(윈도)
- 목적지 단말까지 중간 경로에 문제가 생긴 경우, icmp error 메시지를 활용해 라우팅 문제가 발생한 경우 파악 가능
- 단, 단말도 멀쩡하고 경로도 문제가 없어도 서비스 포트가 정상 상태인지는 ping으로 확인할 수 없다
- 중간 방화벽 등에서 막지는 않는지, 운영체제에서 방화벽이 막는 건 아닌지, 서비스 포트가 닫힌 건 아닌지 알 수 없다
- 또한 ping의 icmp 메시지가 내부 네트워크 상태 정보를 외부에 유출할 수 있어 정책적으로 icmp와 traceroute를 차단하는 경우도 많다
- naver는 ping이 막혀있다.

- tcping 사용하면 포트 확인도 가능하다.

~~

### 8.3.3 traceroute(리눅스)/tracert(윈도)
- 출발지부터 목적지까지의 네트워크 경로 확인
- traceroute는 중간 경로의 더 상세한 정보를 얻는 데 사용
- 중간 네트워크 장비가 아닌 출발지 pc에서 목적지까지의 라우팅 경로 확인
- 목적지까지의 통신에 문제가 있다면 어느 구간부터 문제가 발생했는지 찾아내는 것도 가능
- 추가로 목적지까지의 네트워크 응답 시간이 느린 경우, 어느 구간에서 응답 시간이 느려졌는지 찾는 것도 가능

- IP 헤더의 TTL 사용
- TTL 1부터 증가하면서 목저지 도달할 때까지 패킷을 반복적으로 전송하면서 경로 추적
- 라우터 지날 때마다 TTL 1씩 줄고, 0이 되면 해당 라우터에서 패킷을 드롭하고 icmp 메시지로 출발지 단말에 패킷 드롭한 이유 알려준다
	- ICMP time exceed 메시지

- traceroute는 이 메시지 전달한 장비의 IP를 출력하는 장비의 IP 출력하면서 경로 추적
- 즉, traceroute 경로 추적은 IP 헤더인 3계층 정보에 의한 경로 추적이므로 2계층 이하의 스위치 장비 추적은 불가능

![](files/Pasted%20image%2020250412161945.png)

- 두 호스트 간 경로가 의도대로 정상인지 확인하려면 각 호스트에서 모두 수행해야 한다
	- 비대칭 경로
- 라우터 같이 L3 장비로만 구성되어있다면 비대칭 경로여도 문제가 없지만 세션을 확인하는 보안 장비가 중간에 있다면 비대칭 경로에 의해 통신이 차단될 수 있다
- 이를 찾아내려면 각 호스트에서 traceroute 수행한 결과값으로 경로를 검증해야 함

- 단말 인터페이스가 2개 이상인 경우 라우팅에 따라 들어오는 인터페이스와 나가는 인터페이스가 다르면 통신 자체가 불가능할 수도 있다

![](files/Pasted%20image%2020250412162042.png)

![](files/Pasted%20image%2020250412162121.png)

- `traceroute [옵션] 목적지_IP 주소`

- `-n` 옵션은 도메인 주소로 표기하지 않고 IP 주소로 직접 표기
- `-n` 옵션이 없으면 DNS에 표기된 IP를 DNS 이름으로 역쿼리 시도하고, 이 작업으로 인해 시간 지연이 생긴다.

![](files/Pasted%20image%2020250412162311.png)

- 보안상의 이유로 중간에 있는 보안 장비에서 icmp 메시지나 UDP 패킷을 차단하는 경우 중간의 라우터 자체에서 자신의 IP가 노출되는 것을 막기 위해 traceroute icmp 메시지에 응답하지 않을 때는 응답 시간이 아니라 `***`로 표기

- 운영체제에 따라 `traceroute`때 수행하는 프로토콜이 다른데 윈도 계열에서는 ICMP, 리눅스/유닉스 계열은 UDP 기반 동작
### 8.3.4 tcptraceroute
- ping과 tcping처럼 서비스 포트를 추가로 확인할 수 있는 traceroute 명령어가 있다. -> `tcptraceroute`

- traceroute처럼 출발지와 목적지까지의 경로를 확인하지만 실제 서비스 포트를 이용해 경로를 추적하므로 서비스 포트가 정상적으로 열리는지 확인할 수 있고, 만약 열리지 않았다면 어느 구간부터 서비스가 막히는지 알 수 있다
- 리눅스에는 `traceroute` 명령어에 서비스 포트를 지정해서 확인 가능
- 윈도우는 `tcptraceroute` 추가로 설치해서 확인할 수 있는데 리눅스도 `tcptraceroute`도 설치 가능
- `traceroute` 설치하면 `tcptraceroute`도 함께 설치된다.

```
tcptraceroute [옵션] 목적지_IP 주소 [서비스 포트]
```

| 옵션                | 설명                                       |
| ----------------- | ---------------------------------------- |
| -n                | ICMP 기반으로 traceroute 확인                  |
| -s source address | 출발지 IP 주소를 지정                            |
| destination port  | 도메인이 아닌 숫자 형식으로 IP 주소를 표시 (도메인 리졸브 미 수행) |

### 8.3.5 netstat(network statistics)
- 서버의 다양한 네트워크 상태를 확인하는 명령어
- 보통 서비스 포트 상태 확인에 많이 쓴다
- 현재 서버에서 특정 서비스가 정상적으로 열려있는지(`LISTENING`), 또는 외부 서비스와 TCP 세션이 정상적으로 맺어져 있는지(`ESTABLISHED`), 서비스가 정상적으로 종료되고 있는지(`TIME_WAIT`, `FIN_WAIT`, `CLOSE_WAIT`) 여부를 확인 가능
- 라우팅 테이블이나 인터페이스 패킷 통계 정보 확인에도 사용 가능

```
netstat [옵션]
```

![](files/Pasted%20image%2020250412205015.png)

- `netstat -ant4`
	- TCP 모든 연결과 수신 대기 정보를 숫자로 표기해 출력

- `netstat -s -p TCP`
	- TCP 프로토콜에 대한 통계 값을 확인

### 8.3.6 ss(socket statistics)
- 소켓 정보를 확인할 수 있는 명령어
- netstat 명령어를 대체하면서 다양한 옵션을 제공해 더 많은 정보를 확인 가능
- 커널 스페이스를 통해 직접 정보를 가져와 netstat보다 더 빠르게 확인 가능

```
ss [옵션] [필터]
```

![](files/Pasted%20image%2020250412205732.png)

- `ss -lp | grep http`
	- LISTENING 상태이면서 현재 소켓에서 사용 중인 목록을 필터링하고, http 서비스에 대해서만 필터링
- `ss -it4 state connected`
	- IPv4 연결 중 TCP 상태가 커넥티드인 연결에 대한 세부적인 정보 확인

### 8.3.7 nslookup(name server lookup)
- DNS에 다양한 도메인 관련 내용을 질의하는 명령어
- 기본적으로는 운영체제에 설정된 네트워크 설정 정보로 DNS 서버 주소로 질의를 보내지만 필요한 경우, 옵션값으로 DNS 서버 변경 가능
	- 이는 도메인 설정 변경이 외부 DNS로 잘 전파되었는지 확인할 때 사용

![](files/Pasted%20image%2020250412205954.png)

- 직접 질의, 대화형 모드 둘 다 지원
- 여러 개 확인할 때는 대화형 모드가 편하다

```
nslookup [옵션]                     # 기본 네임 서버를 사용한 대화형 모드
nslookup [옵션] - server            # 기본 네임 서버를 server로 지정한 대화형 모드
nslookup [옵션] host                # 기본 네임 서버를 사용한 host 질의
nslookup [옵션] host server         # 기본 네임 서버를 server로 지정한 host 질의
```

- A 레코드에 대한 값을 질의하고 결과를 받는다
- 다른 레코드 확인하려면 `set type` 옵션으로 설정 확인 가능

| 설정값  | 설명                           |
| :--: | ---------------------------- |
|  A   | 해당 도메인의 IPv4 주소 정보를 확인합니다.   |
| AAAA | 해당 도메인의 IPv6 주소 정보를 확인합니다.   |
| ANY  | 해당 도메인의 모든 DNS 설정 정보를 확인합니다. |
|  MX  | 해당 도메인의 메일 서버 설정 정보를 확인합니다.  |
|  NS  | 해당 도메인의 네임 서버 설정 정보를 확인합니다.  |
| PTR  | IP 주소에 대한 역방향 도메인 정보를 확인합니다. |

- 대화형 모드를 사용하려면 `nslookup` 명령어 쳐서 사용

### 8.3.8 telnet(tale network)
- 원격지 호스트에 터미널 연결을 위해 사용되는 매우 오래된 표준 프로토콜
- 네트워크 문제 해결을 위해 특정 서버의 서비스에 접근 가능성을 테스트할 때도 많이 쓰인다
- 평문을 사용하므로 네트워크에 접근 가능한 해커에 의해 통신 내용을 감청 당할 수 있어 보안적으로 위험하다.
- 서버 접근 관리 용도로는 암호화되어 통신 내용을 감청할 수 없는 SSH 사용이 권고된다.

```
telnet 목적지 IP 서비스 포트
```

- 텔넷으로 서비스를 테스트할 때 접근이 불가능한 이유는 여러 가지이지만, 보통 다음 몇 가지
- 출발지 네트워크 설정이나 연결이 올바르다면
	- 출발지부터 서비스가 동작 중인 서버까지의 경로가 정상적으로 잡혀있지 않은 경우
		- 네트워크 경로 문제라면 네트워크 장비 접근 없이 출발지, 도착지 단말에서도 ping 테스트와 traceroute 명령어로 대략적인 문제 파악 가능
	- 출발지로부터 해당 서비스가 동작 중인 서버까지의 경로가 보안 장비 등에 의해 차단된 경우
		- 보안 장비에 의해 차단된 경우, 다른 포트나 ICMP 프로토콜을 이용하는 ping, traceroute 사용해서 일부 파악 가능
		- 보안 장비의 위치를 알고 있다면 보안 장비를 지나는 경우, 지나지 않는 경우로 나누어 테스트해보고 문제를 파악할 수 있다
	- 도착지 단말의 방화벽이나 iptables와 같은 보안 기능에서 차단된 경우
		- 단말의 방화벽 기능을 일시적으로 내리고 테스트해 문제를 파악할 수 있다
	- 도착지 단말이 정상적으로 서비스가 열려 있지 않은 경우 (서비스 포트가 Listening 상태가 아니거나 서버 서비스가 구동되지 않았거나 다른 포트로 매핑되어 서비스가 올라온 경우)
		- netstat, ss 명령어로 서비스가 정상적으로 동작하고 있는지, 어떤 프로세스와 포트가 연동되는지 파악해 문제를 해결할 수 있다


### 8.3.9 ipconfig
- 자주 사용하는 두 가지 옵션을 추가로 알아보자

- DHCP 환경에서 할당받은 현재 IP 주소를 해제하고 갱신하는 옵션
	- `ipconfig /release`
		- 네트워크 주소 해제
	- `ipconfig /renew`
		- 네트워크 주소 갱신
- IP 주소를 정상적으로 할당받지 못한 경우, 위 작업이 필요
- DHCP를 통해 IP 할당이 정상적으로 안 되는 경우, IP 주소가 없으면 어떤 통신도 불가능하므로 단말에서 자체적으로 `169.254.0.0/16` 대역의 IP를 할당
- 물론 DHCP를 통해 할당받은 IP의 재갱신이 필요할 때도 사용 가능

- 도메인에 대한 로컬 캐시 정보 지우기
	- `ipconfig /flushdns`
	- 동적 쿼리인 DNS 쿼리 정보는 모두 삭제되고, 로컬 hosts 정보만 남는다
	- nslookup은 캐시와 무관하게 항상 DNS 서버를 찌른다
	- 따라서 nslookup은 정상이어도 DNS 캐시 문제로 통신이 안 될 수도 있다
	- 이를 해결하기 위해서는 DNS 캐시를 지울 필요가 있다.

- 캐시 정보를 확인할 때는 `ipconfig /displaydns` 사용

- APIPA(Automatic Private IP Addressing)
	- DHCP에서 IP 주소를 할당받지 못한 경우, 호스트 컴퓨터 스스로 IP 주소를 자동으로 할당해주는 기능
	- DHCP 서버가 없거나 정상적으로 동작하지 않을 때도 IP 주소를 자동으로 할당해 통신이 가능하게 해줌
	- 이때 IANA에서 이를 위해 예약해둔 IP 주소 범위(169.254.0.0/16) 사용

### 8.3.10 tcpdump
- 네트워크 인터페이스로 오가는 패킷을 캡처해 보는 기능
- 장애 처리나 패킷 분석이 필요할 때 자주 사용
- 전체 패킷을 캡처하면 분석이 어려우므로 보통 옵션을 이용해 필요한 패킷만 필터링

| 주요 옵션          | 설명                                                              |
|-----------------|-----------------------------------------------------------------|
| -i 인터페이스      | 패킷을 캡처할 인터페이스                                                |
| src IP 주소       | 출발지 IP 주소를 지정해 필터링                                          |
| dst IP 주소       | 목적지 IP 주소를 지정해 필터링                                          |
| host IP 주소      | 출발지/목적지와 상관없이 IP 주소를 지정해 필터링                              |
| -n               | 이름으로 표기되는 호스트 네임을 실제 IP 주소로 표기<br>(예: Localhost → 127.0.0.1)   |
| -nn              | 이름으로 표기되는 서비스 포트를 실제 포트 번호로 표기<br>(예: http → 80)           |
| src port 포트 번호 | 출발지 포트를 지정해 필터링                                            |
| dst port 포트 번호 | 목적지 포트를 지정해 필터링                                            |
| port 포트 번호     | 출발지/목적지와 상관없이 tcp 포트를 지정해 필터링                           |
| tcp 또는 udp      | tcp 또는 udp만 필터링                                             |
| -c 출력 수        | tcpdump로 출력할 결과의 개수                                        |
| -w 파일명         | tcpdump의 결과를 화면에 출력하지 않고 파일명으로 저장                          |
| -r 파일명         | 파일로 저장한 tcpdump 파일을 화면에 출력                               |

- 필터링 옵션은 `and`나 `or`로 결합 가능
- 조건 앞에 `not` 붙이는 것도 가능

- 웹 서비스 패킷만 캡쳐하고 싶다면 tcp, port 옵션 사용
	- `tcpdump -i eth0 tcp port 80`
- 172.16.10.10이 출발지 또는 목적지이면서 HTTP 서비스 패킷 캡처
	- `tcpdump -i eth0 tcp port 80 and host 172.16.10.10`
- 22포트 제외한 전체 패킷 캡처
	- `tcpdump -i eth0 not tcp port 22`
- 파일로 저장
	- `tcpdump -i eth0 -w dumpfile.pcap`
	- 와이어샤크로 불러올 수 있다.

```toc
```

# 1장 네트워크 시작하기


## 1.1 네트워크 구성도 살펴보기
### 1.1.1 홈 네트워크
![](files/Pasted%20image%2020250215172924.png)

![](files/Pasted%20image%2020250215172940.png)

- 홈 네트워크 구성은 어떤 인터넷 회선(FTTH, 케이블 인터넷, VDSL)을 연결하더라도 똑같다.
- 홈 네트워크를 구성하는 데는 모뎀, 공유기, 단말 간의 물리적 연결이 필요하다.
- 무선 연결은 무선 랜 카드와 무선 신호를 보낼 수 있는 매체(공기)가 필요하고 유선 연결은 무선 랜 카드(이더넷 랜 카드), 랜 케이블이 필요하다.

### 1.1.2 데이터 센터 네트워크
 - 데이터 센터 네트워크는 안정적이고 빠른 대용량 서비스 제공을 목표로 한다.
 - 안정적인 서비스 제공을 위해 다양한 이중화 기술이 필요
 - 많은 서버가 네트워크에 연결되므로 높은 통신량을 수용할 수 있어야 함
 - 이를 위해 10G, 25G, 40G, 100G, 400G 등 고속 인터넷 기술 쓰인다

![](files/Pasted%20image%2020250215173008.png)
- 기존 데이터 센터는 3계층 구성이 일반적이었지만, 가상화 기술과 높은 대역폭을 요구하는 서비스가 등장하면서 2계층 구성인 Spine-Leaf 구조로 바뀜
- Spine-Leaf 구조는 서버 간 통신이 늘어나는 최신 경향을 지원하기 위해서 제안되었다
- 일반 서버에 10G Base-T 이더넷 포트가 기본적으로 제공되어 TOR(Top of Rack) 스위치와 연결되고 Leaf 스위치인 TOR 스위치는 Spine 스위치와 40G, 100G와 연결되는 추세
- 더 높은 대역폭 제공을 위해 400G 네트워크도 표준화되어 사용되고 있다.

![](files/Pasted%20image%2020250215173952.png)

- TOR 스위치
	- 서버 랙 상단에 배치되어 있는 스위치
	- TOR 스위치는 대부분 L2, 경우에 따라 L3인 경우도 있음

- 3-Tier 아키텍처
	- 전통적인 데이터센터, 캠퍼스 네트워크 등에 많이 쓰임
	- North-South -> 사용자 <-> 서비스 트래픽이 대부분인 경우 많이 쓰임
	- 익숙하고, 모듈 형식이라 특정 구역의 장애가 전체에 전파되지 않고
	- Scale-out / Scale-up이 용이해 확장성도 괜찮았음
	- 단, 구조 변경이 어렵고 
	- STP가 동작하면 전체 대역폭을 쓸 수 없고
	- East to West 트래픽도 Core 등을 거쳐가야 하므로 비효율적
- 2-Tier 아키텍처
	- 기존 3-Tier 아키텍처는 서버 간 통신이 많은 경우 비효율적
	- 2-Tier 아키텍처는 Leaf 간 최대 2 hop이라 효율적
	- Leaf 스위치와 Spine 스위치 간 STP(Spaning Tree Protocol) 없이 모든 링크를 사용해서 트래픽 전송
		- L2에서는 TRILL 혹은 SPB, L3에서는 VXLAN 사용해서 STP 대체 가능
	- 모든 디바이스는 Leaf 스위치와 연결되고 Spine이 Backbone 역할
	- 단, 모든 Leaf 스위치와 Spine 스위치가 연결되어야 하므로 많은 케이블 연결 필요
	- HOST 수량은 스위치 포트 수에 영향을 받음

- 10GBase-T
	- 10G : 10Gbps 속도 지원
	- Base는 케이블 종류
		- Baseband : 디지털 방식
		- Broadband : 아날로그 방식
	- T : Twisted Pair 방식
	- 뒤에 숫자가 나오면 최대 통신 거리
		- 10 Base 5 : 500m 까지 통신 가능

![](files/Pasted%20image%2020250215174748.png)

## 1.2 프로토콜
- 예전에는 어디서 만들었냐에 따라 프로토콜이 다양했지만
- 현재는 이더넷-TCP/IP 기반 프로토콜로 변경됨
	- 물리적 측면
		- 데이터 전송 매체, 신호 규약, 회선 규격 등. 이더넷 
	- 논리적 측면
		- 장치들끼리 통신하기 위한 규격. TCP/IP

- 자연어로 통신하면 편하겠지만 한정된 자원으로 통신하다 보니 최대한 적은 데이터로 효율적으로 통신해야 했음
- 그래서 대부분의 프로토콜이 문자 기반이 아닌 2진수 비트 기반으로 만들어짐
- 단, 애플리케이션 레벨의 프로토콜은 비트 기반이 아닌 문자 기반이 많이 쓰이고 있음
	- HTTP, SMTP 등
	- 효율성은 떨어지지만 다양한 확장이 가능

- 일반적으로 TOCP/IP는 프로토콜이라고 부르지 않고 프로토콜 스택이라고 부른다
- TCP와 IP는 별도 계층에서 동작하는 프로토콜이지만 함께 사용하고 있다 -> 그래서 프로토콜 스택이라고 부름
- 실제로 TCP/IP 프로토콜 스택에는 TCP와 IP뿐만 아니라 UDP, ICMP, ARP, HTTP, SMTP, FTP 등 다양한 애플리케이션 레이어 프로토콜 존재

![](files/Pasted%20image%2020250215175438.png)

- TCP/IP 프로토콜 스택은 총 4개의 부분으로 나뉨
	- 물리 부분인 이더넷
	- 데이터가 목적지를 찾아가도록 해주는 네트워크 계층
	- 잘린 패킷을 데이터 형태로 잘 조합해주는 전송 계층
	- 그리고 애플리케이션 계층

## 1.3 OSI 7계층과 TCP/IP
- OSI 7계층과 TCP/IP 스택은 복잡한 네트워크를 단계별로 나누어 이해하기 쉽도록 도와준다

### 1.3.1 OSI 7계층
- OSI 7계층이 네트워크 동작을 나누어 이해하고 개발하는데 도움이 많은 도움이 되므로 네트워크의 주요 레퍼런스 모델로 활용된다
- 하지만 현재는 대부분의 프로토콜이 TCP/IP 프로토콜 스택 기반으로 되어있다.

![](files/Pasted%20image%2020250215175726.png)

- 복잡한 데이터 전송 과정을 OSI 7계층으로 나누어 보면 이해하기 쉽고
- 계층별로 표준화된 프로토콜 템플릿을 통해 네트워크 프로토콜을 전부 개발하는 대신 계층별로 프로토콜을 개발해 네트워크 구성 요소를 보듈화할 수 있다

- OSI 7계층은 다시 두 가지 계층으로 나눌 수 있다
	- 1 ~ 4계층
		- Data Flow Layer
		- 하위 계층
		- 데이터를 상대방에게 잘 전달하는 역할
		- 덕분에 애플리케이션 개발자는 데이터 전송은 신경쓰지 않고 데이터 표현에만 집중할 수 있다
		- 단, 애플리케이션 계층은 네트워크 엔지니어가 잘 고민하지 않는다
	- 5 ~ 7계층 
		- Application Layer
		- 상위 계층

### 1.3.2 TCP/IP 프로토콜 스택
- 현대 네트워크는 대부분 TCP/IP와 이더넷으로 이루어져있다
- TCP/IP는 이론보다는 실용성에 중점을 둔 프로토콜

![](files/Pasted%20image%2020250215180031.png)

- OSI 레퍼런스 모델은 7계층이지만 TCP/IP 모델은 4계층이다
- 상위 3계층을 애플리케이션 계층으로 묶고, 1~2계층을 하나의 네트워크 계층으로 구분
	- 좀 더 현실을 반영한 모델


## 1.4 OSI 7계층별 이해하기
### 1.4.1 1계층(피지컬 계층)
- 1계층은 물리 계층으로 물리적 연결과 관련된 정보 정의
- 주로 전기 신호 전달에 초점
- Hub, Repeater, Cable, Connector, Tranceiver, TAP 등이 주요 장비
- 트래시버는 컴퓨터의 랜카드와 케이블을 연결하는 장비
- TAP은 네트워크 모니터링과 패킷 분석을 위해 전기 신호를 다른 장비로 복제해줌

- 1계층은 전기 신호를 그대로 잘 전달하는 게 목적이므로 전기 신호가 1계층 장비에 들어오면 이를 재생성해서 내보낸다
- 주소 개념이 없으므로 들어온 포트를 제외한 모든 포트에 같은 전기 신호를 전송

### 1.4.2 2계층(데이터 링크 계층)
- 데이터 링크 계층으로 전기 신호를 모아 우리가 알아볼 수 있는 데이터 형태로 처리
- 1계층과는 다르게 전기 신호를 정확히 전달하기 보다는 주소 정보를 정의하고, 정확한 주소로 통신이 되도록 하는 데 초점
- 1계층은 전기 신호를 잘 보내는 게 목적이니 출발지와 목적지를 구분할 수 없지만 2계층에서는 출발지와 도착지 주소를 확인하고 내가 보낸 것이 맞는지, 또는 내가 처리해야 하는지 검사 후  데이터를 처리한다

- 주소 체계가 생기면서 여러 통신이 한꺼번에 이루어지는 것을 구분하기 위한 기능이 주로 정의됨
- 전기 신호를 모아 데이터 형태로 처리하므로 데이터에 대한 에러를 탐지하거나 고치는 역할을 수행
	- 과거에는 신뢰할 수 없는 미디어를 이용해 통신하는 경우도 많아 탐지뿐만 아니라 고치거나 재전송도 담당했지만
	- 이더넷 기반 네트워크의 2계층에서는 에러를 탐지하는 역할만 수행한다

- 주소 체계가 생긴다는 것은 한 명과 통신하는 것이 아니라 동시에 여러 명과 통신할 수 있다는 것이므로 무작정 데이터를 던지는 게 아니라 현재 데이터를 받을 수 있는지 확인하는 작업부터 필요
- 이를 Flow Control이라고 한다.

![](files/Pasted%20image%2020250215182820.png)

- 2계층에서 동작하는 네트워크 구성욧는 네트워크 인터페이스 카드와 스위치다.
- 2게층의 가장 중요한 건 MAC 주소라는 주소 체계가 있다느 ㄴ것
- 2계층에서 동작하는 네트워크 인터페이스 카드와 스위치 모두 MAC 주소를 이해할 수 있고 스위치는 MAC 주소를 보고 통신해야 할 포트를 지정해 내보내는 능력이 있다.

- 네트워크 인터페이스 카드를 부르는 용어는 매우 많다
	- NIC(Network Interface Controller)
	- Network Card
	- Lan Card
		- 과거 이더넷은 LAN에서만 사용되다 보니
	- Physical Network Interface
		- 물리적으로 컴퓨터의 내부와 외부를 연결해주는 중간 지점이라는 의미
		- 보통 이 용어를 사용할 경우, 네트워크 인터페이스 카드를 1계층 구성요소로 오해할 수 있지만 2계층이다
	- Ethernet Card
		- 대부분의 네트워크가 이더넷 연결이라서
	- Network Adapter


![](files/Pasted%20image%2020250215183118.png)
1. 전기 신호를 데이터 형태로 만든다
2. 목적지 MAC 주소와 출발지 MAC 주소를 확인
3. 네트워크 인터페이스 카드의 MAC 주소를 확인
4. 목적지 MAC 주소와 네트워크 인터페이스 카드가 갖고 있는 MAC 주소가 맞으면 데이터를 처리하고 다르다면 데이터를 폐기한다

- 네트워크 인터페이스 카드에는 고유 MAC 주소가 있다
- 입력되는 전기 신호를 데이터 형탤 만들고, 데이터에서 도착지 MAC 주소를 확인한 후 자신에게 들어오는 전기 신호가 맞는지 확인
- 자신에게 들어오는 전기 신호가 아니면 버릭 맞으면 이 데이터를 상위 계층에서 처리할 수 있도록 메모리에 적재

![](files/Pasted%20image%2020250215183128.png)

- 스위치는 단말(Terminal)이 어떤 MAC 주소인지, 연결된 포트는 어느 것인지 주소 습득(Adress Learning) 과정에서 알 수 있다
- 이 데이터를 기반으로 단말들이 통신할 때 포트를 적절히 필터링하고 정확한 포트로 포워딩해준다

- 반면 1계층에서 동작하는 허브는 한 포트에서 전기 신호가 들어오면 전체 포트로 전기 신호를 전달하다 보니 전체 네트워크에서 동시에 오직 하나의 장비만 데이터를 내보낼 수 있다
- 스위치의 적절한 필터링과 포워딩 기능으로 통신이 필요한 포트만 사용하고 네트워크 전체에 불필요한 처리가 감소하면서 이더넷 네트워크 효율성이 크게 향상되고, 이더넷 기반 네트워크가 급증하는 계기가 되었다

### 1.4.3 3계층(네트워크 계층)
- 3계층에서는 IP 주소와 같은 논리적인 주소가 정의된다
- 데이터 통신을 할 때는 두 가지 주소가 사용됨
	- 2계층의 물리적인 MAC 주소와 3계층의 논리적인 IP 주소
- MAC 주소와 달리 IP 주소는 사용자가 환경에 맞게 변경해 사용할 수 있고 네트워크 주소 부분과 호스트 주소 부분으로 나뉜다.

- 3계층을 이해할 수 있는 장비는 네트워크 주소 정보를 이용해 자신이 속한 네트워크와 원격지 네트워크를 구분할 수 있고, 원격지 네트워크를 가려면 어디로 가야 하는지 경로를 지정하는 능력이 있다.

![](files/Pasted%20image%2020250215183651.png)

- IP 주소는 주소를 나누는 구분점이 3개이므로 어디가 네트워크고 어디가 호스트인지 알기 어려운 데 이건 뒤에서 다룬다

- 3계층에서 동작하는 장비는 라우터
- 라우터는 3계층에서 정의한 IP 주소를 이해할 수 있다
- IP 주소를 이용해 최적의 경로를 찾고 해당 경로로 패킷을 전송

![](files/Pasted%20image%2020250215184231.png)

### 1.4.4 4계층(트랜스포트 계층)
- 하위 계층인 1,2,3 계층은 신호와 데이터를 올바른 위치로 보내고 실제 신호를 잘 만들어내는 역할에 집중
- 반대로 4계층은 실제로 해당 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 맡는다
- 페킷 네트워크는 데이터를 분할해 패킷에 실어보내다 보니 중간에 패킷이 유실되거나 순서가 바뀌는 경우가 생긴다
- 이 문제를 해결하기 위해 패킷이 유실되거나 순서가 바뀌었을 때 바로잡아 주는 역할을 바로 4계층이 맡는다
	- 패킷을 분할할 때 헤더에 보내는 순서와 받는 순서를 적어 통신하므로 유실되면 재전송을 요청할 수 있고, 순서가 바뀌어도 바로잡을 수 있다
	- 보내는 순서를 시퀀스 번호(Sequence Number)라고 하고, 받는 순서를 ACK 번호(Acknowledgement Number)라고 한다
	- 이뿐만 아니라 장치 내의 많은 애플리케이션을 구분할 수 있도록 포트 번호를 사용해 상위 애플리케이션을 구분

- 4계층에서 동작하는 장비로는 로드 밸런서와 방화벽이 있다
- 애플리케이션 구분자(포트 번호)와 시퀀스, ACK 번호 정보를 이용해 부하를 분산하거나 보안 정책을 수립해 패킷을 통과, 차단하는 역항르 한다

### 1.4.5 5계층 (세션 계층)
- 세션 계층은 양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고 연결이 안정적으로 유지되도록 관리하고 작업 완료 후에는 연결을 끊는 역할
- 흔히 우리가 아는 세션을 관리하는 것이 주요 역할
- 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행

### 1.4.6 6계층(프레젠테이션 계층)
- 표현 방시이 다른 애플리케이션이나 시스템 간의 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환하는 기능 수행
- 일종의 번역기나 변환기 역할 수행
- 응용 계층에서 데이터의 형식상 차이를 다루는 부담을 줄여줌
- MIME 인코딩, 암호화, 압축, 코드 변환 등

### 1.4.7 7계층(애플리케이션 계층)
- 애플리케이션 프로세스를 정의하고 애플리케이션 서비스를 수행
- 네트워크 소프트웨어의 UI 부분이나 사용자 입출력 부분을 저으이
- FTP, SMTP, HTTP, TELNET 등


## 1.5 인캡슐레이션과 디캡슐레이션
![](files/Pasted%20image%2020250215185006.png)

- 하위 계층에서 상위 계층으로 데이터를 보내는 걸 Encapsulation, 받는 과정을 Decapsulation이라고 부른다.

- 현대 네트워크는 대부분 패킷 기반
- 패킷 네트워크는 데이터를 패킷이라는 작은 단위로 쪼개서 보낸다
- 이런 기법으로 하나의 통신이 회선 전체를 점유하지 않고 동시에 여러 단말이 통신하도록 해준다
- 데이터를 패킷으로 쪼개고 네트워크를 이용해 목적지로 보내고 받는 쪽에서 패킷을 다시 큰 데이터 형태로 결합해서 사용

- 애플리케이션에서 데이터를 Data flow 계층(1~4)으로 내려보내면서 패킷에 데이터를 넣을 수 있도록 분할
	- 이를 Encapsulation이라고 부른다
- 네트워크 상황을 고려해 적절한 크기로 데이터를 쪼개고 4계층부터는 네트워크 전송을 위한 정보를 헤더에 넣는다
- 헤더 정보는 4계층, 3계층, 2계층에서 각각 자신이 필요한 정보를 추가하는데 이 정보는 미리 정의된 비트 단위로 쓴다
- 데이터 한 개를 전송하는 작업은 생각보다 복잡해 Data flow 계층에서만 3개의 헤더 정보가 추가된다

- 반대로 받는 쪽에서는 Decapsulation 과정을 수행
- 받은 전기신호를 데이터 형태로 만들어 2계층으로 올려보낸다
- 2계층은 송신자가 작성한 2계층 헤더 정보를 확인
	- 목적지가 자신이 아니면 버린다
	- 랜카드가 이 작업을 담당
	- 맞다면 3계층으로 올려보냄
	- 데이터를 상위 계층으로 보낼 때 2계층의 헤더 정보는 필요 없으므로 벗겨내고 올린다
- 3계층은 2계층처럼 3계층 헤더 정보를 확인해 자신에게 온 정보가 맞는지 확인하고, 맞다면 헤더 정보를 제거하고 4계층으로 보낸다
- 4계층도 비슷한 작업 후 애플리케이션에 올려보냄

- 이런 작업은 2가지 정보 흐름으로 설명 가능
	- 인캡슐레이션, 디캡슐레이션 과정을 통해 데이터가 전송되는 과정
	- 각 계층 헤더를 이용해 송신자 계층과 수신자 계층 간의 논리적 통신 과정

- 하위 계층으로 보내면서 헤더 정보 추가, 상위 계층으로 보내면서 헤더 정보 확인하고 헤더 제거해서 올려보냄

![](files/Pasted%20image%2020250215185653.png)

- 데이터 인캡슐레이션 과정에서 헤더에 넣는 저보가 꽤 많아 모두 이해하는 게 쉽지 않음
- 또 프로토콜마다 특성이 달라서 이 모든 걸 이해하려면 많은 공부가 필요함
- 다만 여기에도 규칙이 있다.
- 두 가지 정보는 반드시 포함되어야 함
	- 현재 계층에서 정의하는 정보
		- 각 계층의 목적에 맞는 정보
			- TCP에서는 Seq, Ack 등
			- 3계층에서는 출발지, 도착지 IP 주소
			- 2계층에서는 출발지, 도착지 MAC 주소
	- 상위 프로토콜 지시자
		- 프로토콜 스택은 상위로 올라갈수록 종류가 많아진다
		- 디캡슐레이션 할 때는 헤더에 아무런 정보가 없으면 어떤 상위 프로토콜로 올려보내지 결정할 수 없다
			- 3계층에서 TCP로 보낼지 UDP로 보낼지 알 수 없다

![](files/Pasted%20image%2020250215185949.png)

표 1-2 잘 알려진 상위 프로토콜 지시자

| 프로토콜 번호 | 프로토콜                            |
| ------- | ------------------------------- |
| 1       | ICMP(Internet Control Message)  |
| 2       | IGMP(Internet Group Management) |
| 6       | TCP(Transmission Control)       |
| 17      | UDP(User Datagram)              |
| 50      | ESP(Encap Security Payload)     |
| 51      | AH(Authentication Header)       |
| 58      | IPv6용 ICMP                      |
| 133     | FC(Fibre Channel)               |

표 1-3 잘 알려진 상위 프로토콜 지시자: 포트 번호

| 포트 번호           | 서비스                                      |
| --------------- | ---------------------------------------- |
| TCP 20, 21      | FTP(File Transfer Protocol)              |
| TCP 22          | SSH(Secure Shell)                        |
| TCP 23          | TELNET(Telnet Terminal)                  |
| TCP 25          | SMTP(Simple Mail Transport Protocol)     |
| UDP 49          | TACACS                                   |
| TCP 53/UDP 53   | DNS(Domain Name Service)                 |
| UDP 67, 68      | BOOTP(Bootstrap Protocol)                |
| TCP 80/UDP 80   | HTTP(HyperText Transfer Protocol)        |
| UDP 123         | NTP(Network Time Protocol)               |
| UDP 161, 162    | SNMP(Simple Network Management Protocol) |
| TCP 443         | HTTPS                                    |
| TCP 445/UDP 445 | Microsoft-DS                             |

표 1-4 잘 알려진 상위 프로토콜 지시자: 이더 타입

| 이더 타입(Ether Type)               | 프로토콜                                |
| ------------------------------- | ----------------------------------- |
| 0x0800                          | IPv4(Internet Protocol version 4)   |
| 0x0806                          | ARP(Address Resolution Protocol)    |
| 0x22F3                          | IETF TRILL Protocol                 |
| 0x8035                          | RARP(Reverse ARP)                   |
| 0x8100                          | VLAN-tagged frame(802.1Q)           |
| Shortest Path Bridging(802.1aq) | AH(Authentication Header)           |
| 0x86DD                          | IPv6(Internet Protocol version 6)   |
| 0x88CC                          | LLDP(Link Layer Discovery Protocol) |
| 0x8906                          | FCoE(Fibre Channel over Ethernet)   |
| 0x8915                          | RoCE(RDMA over Converged Ethernet)  |

- 각 계층마다 이 상위 프로토콜 지시자를 가지고 있지만 이름이 달라 4계층은 포트 번호, 3계층은 프로토콜 번호, 2계층은 이더 타입(Ehter Type)이라고 부른다
- 포트 번호는 4계층 헤더이지만 애플리케이션 계층에서는 프로토콜 종류를 나타내주는 정보다
- 디캡슐레이션할 때는 상위 프로토콜 지시자 정보를 이용해 어느 상위 프로토콜로 보내야 할지 구분해야 하므로 동작하는 계층보다 한 계층 위의 정보가 적힌다.

![](files/Pasted%20image%2020250215190539.png)

- MSS, MTU (데이터 크기 조절)
	- Data Flow 계층에서는 네트워크 상황에 맞게 크기를 잘 쪼개서 보내야 한다
	- 네트워크에서 수용할 수 있는 크기를 역산정해 데이터가 4계층으로 내려올 때 적절한 크기로 쪼개질 수 있도록 유도하는데, 이 값을 MSS(Maximum Segment Size)라고 부른다
	- 네트워크에서 한 번에 보낼 수 있는 데이터 크기를 MTU(Maximum Transmission Unit)라고 부르며 일반적인 이더넷에서 수용할 수 있는 크기는 1,500 바이트다.
	- MTU와 MSS는 모두 데이터 크기를 지칭하는 것이므로 MTU 값은 2계층의 데이터 값, MSS는 4계층에서 가질 수 있는 최대 데이터 값
	- 2계층에서는 2계층 헤더 크기 제외한 데이터 크기를 MTU 크기라고 부른다
	- IP 헤더와 TCP 헤더의 표준 헤더 크기는 일반적으로 각 20바이트이므로 일반 이더넷은 MSS를 1,460 바이트로 사용한다.



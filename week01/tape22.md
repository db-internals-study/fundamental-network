# 1장

### 1-1. 네트워크 구성

데이터 센터 네트워크는 안정적으로 서비스를 제공해야해서 고속 이더넷 기술이나 이중화가 필요해짐

- 3계층 (Core-Distribution-Access 방식) → 2계층인 spine-leaf(TOR(leaf switch), spine switch) 구조의 변화

**왜 3계층은 스케일 아웃이나 가상화 기술을 수용하지 못할까?**

- 3계층은 트래픽이 Distribution 스위치에서 aggregate 된 후 core에서 최종처리되는 수직구조여서 서버 간 통신이 많아질수록 스위치가 병목이 됨
- 이에 비해 spine-leaf는 spine은 단순히 패킷을 전달하고 leaf가 서버와 연결되는 구조이기 때문에 확장하기 편리하다.
    - core 스위치를 늘려도, distribution에서 처리를 많이 못하면 병목이 될 뿐더러 distribution 스위치를 늘리면 또 core에 다시 다 연결하고 둘 다 증설해야하니까 복잡함
    - spine 스위치가 core역할 하고, leaf가 distribution + access 역할을 하면서 새 스위치를 추가하고싶으면 그냥 leaf가 모든 core에 연결되기만 하면 확장이 끝난다.

---

### 프로토콜

- 이더넷 : 유선 통신기술 표준 (physical , data link 계층)
    - LAN선, NIC, switch 등 물리적인 네트워크 장비부터
    - frame, mac address 등 데이터를 패킷으로 변환하기 위한 정보 규약(프로토콜)까지 포함
- TCP/IP
    - TPC/IP는 하나의 프로토콜 “스택”이고
    - 실제 물리적인 부분을 담당하는 이더넷과 / 데이터의 목적지를 찾는 network 계층 / 패킷을 데이터 형태로 다시 조합하는 transport, application 계층을 포함

예전에는 기술력의 부족으로 **bit 기반 프로토콜**로 철저하게 규약을 지켜야했다면,

현재 HTTP, SMTP 와 같이 **문자 기반의 프로토콜**은 헤더 정의 등으로 데이터를 보내는 쪽에서 다양한 설정을 추가해서 확장이 가능하다.

---

### OSI 7계층과 TCP/IP 프로토콜 스택의 차이

OSI 7계층은 데이터 전송과정을 나누어둔 개념적인 계층이고 TCP/IP 프로토콜이 주로 사용되고 있다.

**계층으로 나눈 이유는 뭘까?**

- 이전에는 벤더 사마다 다 규약이 달라서 호환에 문제가 있었는데, 계층 별로 나누어서 모듈화를 하면 연동해서 쓰거나 재사용이 가능해짐
- 처리하는 비즈니스 로직은 비슷한데 개발자 여러 명이 각자 클래스랑 함수 파서 개발하고 있었던 셈
    - 그러다 다른 개발자가 짠 코드를 쓰고싶은데, 각자 모델이 달라서 사용하는데 불편함
    - 하나의 도메인 모델을 두고 해당 객체를 기반으로 주고받으면 새로운 기능을 붙여도 이전 함수를 가져다 쓸 수 있다 같은 느낌으로 이해하면 되려나.

또 계층을 분리해두면, 각 계층 별로 새로운 기술을 적용해야할 때 변경사항이 해당 계층에만 국한되고, 문제가 발생했을 때도 쉽게 파악도 가능해짐

=> OSI 7계층은 ”네트워크를 이렇게 구조화해서 표준화하면 좋겠다“

이에 비해 TCP/IP 프로토콜 스펙은 실용성 측면

- 실질적으로 인터넷에서 사용될 수 있도록 단순화한 모델로, 데이터를 효율적으로 전송하기 위한 목적
- network access - internet - transport - application

=> TCP/IP는 ”인터넷 환경에서 구현되기 쉽게 심플하게 정리해보자“

---

### OSI 7 계층

1계층 (physical)

- 전기 신호를 전달하는 장비
- 전기신호를 받으면 단순히 다른 모든 포트에 해당 전기신호를 재생성해서 전송하는 역할
- 장비는 네트워크 장비가 될 수 있고, 케이블 선, 실제 컴퓨터 LAN 카드랑 케이블을 연결하는 트랜시버 장치 등이 있음

2계층(data link)

- 전기신호들을 받아서 데이터 형태로 처리하는데, 출발지, 도착지 주소를 확인
- 전기신호를 처리하는 **NIC**(network interface card)이 있어서 mac address 주소를 확인하고 이 데이터가 맞게 들어온 전기신호면 메모리에 적재하고, 아니면 폐기한다. (해당 데이터는 이더넷 프레임)
    - 데이터가 잘못되었는지 확인이 가능해지는 계층이라 에러를 탐지하기도한다.
- 스위치는 해당 터미널이 가진 mac address, port를 address learning을 통해 확인하고 적절하게 필터링하거나 포워딩하는 역할의 장비.

3계층 (network)

- IP 논리주소 (mac address는 실제 단말기에 박혀있는 물리적인 고유한 주소값이지만 IP는 계속 변경되는 값)
- 라우터 장비가 ip 주소를 이해하고 최적의 경로를 찾아서 패킷을 전송해준다.

=> 여기까지가 신호와 데이터를 올바른 위치로 보내는 역할

4계층 (transport)

- 해당 데이터가 정상적으로 잘 보내졌는지 확인하는 역할
- 하나의 거대한 데이터를 한 덩이로 보낼 수 없어서, 패킷 단위로 쪼개서 보내는데 이럴 때 패킷이 중간에 유실되진 않았는지, 순서가 맞는지 시퀀스 번호랑 ack 번호를 보고 확인한다.
- L4 로드밸런서는 이 데이터랑 port 번호를 보고 부하를 분산하거나, 방화벽으로 보안정책을 수립해서 패킷을 통과/차단하는 기능이 있다.

5계층 (session)

- 각각 응용 프로세스 간의 연결을 돕고, 유지하고, 끝나면 적절하게 끊는 것.
- 에러로 통신이 중단되면 해당 통신을 복구하고 재전송하는 것도 수행
    - **4계층에서 패킷이 유실될 때 재전송하는 거랑은 어떤 차이가 있지?**

      → 4계층은 네트워크에서 패킷이 유실되었음을 감지하고 복구하기위해 재전송을 수행하는 것이고 5계층부터는 checkpoint 기준으로 세션을 다시 복구하는 개념


6계층 (presentation)

- 암호화, 압축, MIME 인코딩 등 각자 다른 표현방식을 갖고 있는 애플리케이션 간의 통신을 수행하기 위해 형식을 변환하는 것

7계층 (application)

- 사용자 입출력, UI 등 실제로 프로세스를 정의하고 서비스가 수행되는 계층
- HTTP, SMTP, FTP, TELNET 등

---

### Encapsulation / Decapsulation

패킷 기반 네트워크

- encapsulation은 데이터를 받아서 패킷 단위로 쪼개면서 필요한 정보들을 계층마다 헤더에 담아서 내려보내면
- decapsulation은 최종적으로 받은 전기신호를 바탕으로 다시 패킷을 만들면서 헤더 값을 참고해서 위로 전달함

헤더는 반드시 현재 계층에서 정의하는 정보와 상위 프로토콜 지시자가 누구인지를 명시한다.

아래 계층은 윗 계층이 정보를 주지않으면 어디서 왔는지, 다시 어디로 보내야하는지 알 수 없으므로 윗 계층은 헤더값에 상위 프로토콜 지시자를 포함해야함.

---

데이터 크기에 대한 키워드

- MSS (maximum segment size) : TCP에서 한 번에 보낼 수 있는 최대 데이터 사이즈 (MTU - (ip header + tcp header), “패킷 사이즈”
- MTU (Maximum transmission unit) : 네트워크 장비에서 한 번에 보낼 수 있는 데이터 사이즈 (1,500byte), 데이터만 포함

TCP는 데이터 보내기 전에 상대방이랑 MSS 값을 협상하는데, 받을 수 있는 최대 크기는 얼마인지 협상해서 그 이상의 데이터는 보내지 않도록 함. (fragmentation 현상을 방지)